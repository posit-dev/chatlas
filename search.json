[
  {
    "objectID": "structured-data.html",
    "href": "structured-data.html",
    "title": "Structured data",
    "section": "",
    "text": "When using an LLM to extract data from text or images, you can ask the chatbot to nicely format it, in JSON or any other format that you like. This will generally work well most of the time, but there‚Äôs no guarantee that you‚Äôll actually get the exact format that you want. In particular, if you‚Äôre trying to get JSON, find that it‚Äôs typically surrounded in ```json, and you‚Äôll occassionally get text that isn‚Äôt actually valid JSON. To avoid these challenges you can use a recent LLM feature: structured data (aka structured output). With structured data, you supply a type specification that exactly defines the object structure that you want and the LLM will guarantee that‚Äôs what you get back.\nimport json\nimport pandas as pd\nfrom chatlas import ChatOpenAI\nfrom pydantic import BaseModel, Field"
  },
  {
    "objectID": "structured-data.html#structured-data-basics",
    "href": "structured-data.html#structured-data-basics",
    "title": "Structured data",
    "section": "Structured data basics",
    "text": "Structured data basics\nTo extract structured data you call the .extract_data() method instead of the .chat() method. You‚Äôll also need to define a type specification that describes the structure of the data that you want (more on that shortly). Here‚Äôs a simple example that extracts two specific values from a string:\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n\nchat = ChatOpenAI()\nchat.extract_data(\n  \"My name is Susan and I'm 13 years old\", \n  data_model=Person,\n)\n\n{'name': 'Susan', 'age': 13}\n\n\nThe same basic idea works with images too:\n\nfrom chatlas import content_image_url\n\nclass Image(BaseModel):\n    primary_shape: str\n    primary_colour: str\n\nchat.extract_data(\n  content_image_url(\"https://www.r-project.org/Rlogo.png\"),\n  data_model=Image,\n)\n\n{'primary_shape': 'letter and shape', 'primary_colour': 'blue and gray'}"
  },
  {
    "objectID": "structured-data.html#data-types-basics",
    "href": "structured-data.html#data-types-basics",
    "title": "Structured data",
    "section": "Data types basics",
    "text": "Data types basics\nTo define your desired type specification (also known as a schema), you use a pydantic model.\nIn addition to the model definition with field names and types, you may also want to provide the LLM with an additional context about what each field/model represents. In this case, include a Field(description=\"...\") for each field, and a docstring for each model. This is a good place to ask nicely for other attributes you‚Äôll like the value to have (e.g.¬†minimum or maximum values, date formats, ‚Ä¶). There‚Äôs no guarantee that these requests will be honoured, but the LLM will usually make a best effort to do so.\n\nclass Person(BaseModel):\n    \"\"\"A person\"\"\"\n\n    name: str = Field(description=\"Name\")\n\n    age: int = Field(description=\"Age, in years\")\n\n    hobbies: list[str] = Field(\n        description=\"List of hobbies. Should be exclusive and brief.\"\n    )\n\nNow we‚Äôll dive into some examples before coming back to talk more data types details."
  },
  {
    "objectID": "structured-data.html#examples",
    "href": "structured-data.html#examples",
    "title": "Structured data",
    "section": "Examples",
    "text": "Examples\nThe following examples, which closely inspired by the Claude documentation, hint at some of the ways you can use structured data extraction.\n\nExample 1: Article summarisation\n\nwith open(\"examples/third-party-testing.txt\") as f:\n    text = f.read()\n\n\nclass ArticleSummary(BaseModel):\n    \"\"\"Summary of the article.\"\"\"\n\n    author: str = Field(description=\"Name of the article author\")\n\n    topics: list[str] = Field(\n        description=\"Array of topics, e.g. ['tech', 'politics']. Should be as specific as possible, and can overlap.\"\n    )\n\n    summary: str = Field(description=\"Summary of the article. One or two paragraphs max\")\n\n    coherence: int = Field(\n        description=\"Coherence of the article's key points, 0-100 (inclusive)\"\n    )\n\n    persuasion: float = Field(\n        description=\"Article's persuasion score, 0.0-1.0 (inclusive)\"\n    )\n\n\nchat = ChatOpenAI()\ndata = chat.extract_data(text, data_model=ArticleSummary)\nprint(json.dumps(data, indent=2))\n\n{\n  \"author\": \"Anthropic\",\n  \"topics\": [\n    \"AI policy\",\n    \"third-party testing\",\n    \"AI safety\",\n    \"regulation\",\n    \"technology\"\n  ],\n  \"summary\": \"This article discusses the importance of third-party testing as a foundation for AI policy, highlighting the need for robust and trusted testing regimes for frontier AI systems. Anthropic argues that developing a testing infrastructure with input from industry, government, and academia is key to mitigating potential harms from AI systems. They call for a structured testing approach where AI systems undergo initial automated tests followed by more thorough evaluations if needed. The piece underscores the necessity for collaboration across sectors to establish trustworthy standards, ensuring that AI advancements do not compromise security or lead to misuse. Anthropic also outlines their efforts to support the development of these testing structures by actively participating in initiatives that share knowledge and advocate for rigorous, fair assessments of AI technologies. They emphasize that a balanced regulatory framework, enhanced transparency, and a diverse testing ecosystem will be essential to maintain safety and innovation in AI development.\",\n  \"coherence\": 85,\n  \"persuasion\": 0.75\n}\n\n\n\n\nExample 2: Named entity recognition\n\ntext = \"John works at Google in New York. He met with Sarah, the CEO of Acme Inc., last week in San Francisco.\"\n\n\nclass NamedEntity(BaseModel):\n    \"\"\"Named entity in the text.\"\"\"\n\n    name: str = Field(description=\"The extracted entity name\")\n\n    type_: str = Field(description=\"The entity type, e.g. 'person', 'location', 'organization'\")\n\n    context: str = Field(description=\"The context in which the entity appears in the text.\")\n\n\nclass NamedEntities(BaseModel):\n    \"\"\"Named entities in the text.\"\"\"\n\n    entities: list[NamedEntity] = Field(description=\"Array of named entities\")\n\n\nchat = ChatOpenAI()\ndata = chat.extract_data(text, data_model=NamedEntities)\npd.DataFrame(data[\"entities\"])\n\n\n\n\n\n\n\n\nname\ntype_\ncontext\n\n\n\n\n0\nJohn\nperson\nworks at Google in New York. He met with Sarah\n\n\n1\nGoogle\norganization\nJohn works there, located in New York\n\n\n2\nNew York\nlocation\nJohn works at Google in this city\n\n\n3\nSarah\nperson\nmet with John, she is the CEO of Acme Inc.\n\n\n4\nAcme Inc.\norganization\nSarah is the CEO of this company\n\n\n5\nSan Francisco\nlocation\nJohn met Sarah there last week.\n\n\n\n\n\n\n\n\n\nExample 3: Sentiment analysis\n\ntext = \"The product was okay, but the customer service was terrible. I probably won't buy from them again.\"\n\nclass Sentiment(BaseModel):\n    \"\"\"Extract the sentiment scores of a given text. Sentiment scores should sum to 1.\"\"\"\n\n    positive_score: float = Field(\n        description=\"Positive sentiment score, ranging from 0.0 to 1.0\"\n    )\n\n    negative_score: float = Field(\n        description=\"Negative sentiment score, ranging from 0.0 to 1.0\"\n    )\n\n    neutral_score: float = Field(\n        description=\"Neutral sentiment score, ranging from 0.0 to 1.0\"\n    )\n\n\nchat = ChatOpenAI()\nchat.extract_data(text, data_model=Sentiment)\n\n{'positive_score': 0.1, 'negative_score': 0.7, 'neutral_score': 0.2}\n\n\nNote that while we‚Äôve asked nicely for the scores to sum 1, which they do in this example (at least when I ran the code), this is not guaranteed.\n\n\nExample 4: Text classification\n\nfrom typing import Literal\n\ntext = \"The new quantum computing breakthrough could revolutionize the tech industry.\"\n\n\nclass Classification(BaseModel):\n\n    name: Literal[\n        \"Politics\", \"Sports\", \"Technology\", \"Entertainment\", \"Business\", \"Other\"\n    ] = Field(description=\"The category name\")\n\n    score: float = Field(description=\"The classification score for the category, ranging from 0.0 to 1.0.\")\n\n\nclass Classifications(BaseModel):\n    \"\"\"Array of classification results. The scores should sum to 1.\"\"\"\n\n    classifications: list[Classification]\n\n\nchat = ChatOpenAI()\ndata = chat.extract_data(text, data_model=Classifications)\npd.DataFrame(data[\"classifications\"])\n\n\n\n\n\n\n\n\nname\nscore\n\n\n\n\n0\nTechnology\n0.85\n\n\n1\nBusiness\n0.10\n\n\n2\nOther\n0.05\n\n\n\n\n\n\n\n\n\nExample 5: Working with unknown keys\n\nfrom chatlas import ChatAnthropic\n\n\nclass Characteristics(BaseModel, extra=\"allow\"):\n    \"\"\"All characteristics\"\"\"\n\n    pass\n\n\nprompt = \"\"\"\n  Given a description of a character, your task is to extract all the characteristics of that character.\n\n  &lt;description&gt;\n  The man is tall, with a beard and a scar on his left cheek. He has a deep voice and wears a black leather jacket.\n  &lt;/description&gt;\n\"\"\"\n\nchat = ChatAnthropic()\ndata = chat.extract_data(prompt, data_model=Characteristics)\nprint(json.dumps(data, indent=2))\n\n{\n  \"physicalAppearance\": {\n    \"height\": \"tall\",\n    \"facialFeatures\": [\n      \"beard\",\n      \"scar on left cheek\"\n    ],\n    \"clothing\": \"black leather jacket\"\n  },\n  \"voice\": \"deep\",\n  \"gender\": \"male\"\n}\n\n\nThis example only works with Claude, not GPT or Gemini, because only Claude supports adding arbitrary additional properties.\n\n\nExample 6: Extracting data from an image\nThe final example comes from Dan Nguyen (you can see other interesting applications at that link). The goal is to extract structured data from this screenshot:\n\n\n\nScreenshot of schedule A: a table showing assets and ‚Äúunearned‚Äù income\n\n\nEven without any descriptions, ChatGPT does pretty well:\n\nfrom chatlas import content_image_file\n\n\nclass Asset(BaseModel):\n    assert_name: str\n    owner: str\n    location: str\n    asset_value_low: int\n    asset_value_high: int\n    income_type: str\n    income_low: int\n    income_high: int\n    tx_gt_1000: bool\n\n\nclass DisclosureReport(BaseModel):\n    assets: list[Asset]\n\n\nchat = ChatOpenAI()\ndata = chat.extract_data(\n    content_image_file(\"images/congressional-assets.png\"), data_model=DisclosureReport\n)\npd.DataFrame(data[\"assets\"])\n\n\n\n\n\n\n\n\nassert_name\nowner\nlocation\nasset_value_low\nasset_value_high\nincome_type\nincome_low\nincome_high\ntx_gt_1000\n\n\n\n\n0\n11 Zinfandel Lane - Home & Vineyard [RP]\nJT\nSt. Helena/Napa, CA, US\n5000001\n25000000\nGrape Sales\n100001\n1000000\nFalse\n\n\n1\n25 Point Lobos - Commercial Property [RP]\nSP\nSan Francisco/San Francisco, CA, US\n5000001\n25000000\nRent\n100001\n1000000\nFalse"
  },
  {
    "objectID": "structured-data.html#advanced-data-types",
    "href": "structured-data.html#advanced-data-types",
    "title": "Structured data",
    "section": "Advanced data types",
    "text": "Advanced data types\nNow that you‚Äôve seen a few examples, it‚Äôs time to get into more specifics about data type declarations.\n\nRequired vs optional\nBy default, model fields are in a sense ‚Äúrequired‚Äù, unless None is allowed in their type definition. Including None is a good idea if there‚Äôs any possibility of the input not containing the required fields as LLMs may hallucinate data in order to fulfill your spec.\nFor example, here the LLM hallucinates a date even though there isn‚Äôt one in the text:\n\nclass ArticleSpec(BaseModel):\n    \"\"\"Information about an article written in markdown\"\"\"\n\n    title: str = Field(description=\"Article title\")\n    author: str = Field(description=\"Name of the author\")\n    date: str = Field(description=\"Date written in YYYY-MM-DD format.\")\n\n\nprompt = \"\"\"\n  Extract data from the following text:\n\n  &lt;text&gt;\n  # Structured Data\n  By Hadley Wickham\n\n  When using an LLM to extract data from text or images, you can ask the chatbot to nicely format it, in JSON or any other format that you like.\n  &lt;/text&gt;\n\"\"\"\n\nchat = ChatOpenAI()\ndata = chat.extract_data(prompt, data_model=ArticleSpec)\nprint(json.dumps(data, indent=2))\n\n{\n  \"title\": \"Structured Data\",\n  \"author\": \"Hadley Wickham\",\n  \"date\": \"2023-10-03\"\n}\n\n\nNote that I‚Äôve used more of an explict prompt here. For this example, I found that this generated better results and that it‚Äôs a useful place to put additional instructions.\nIf I let the LLM know that the fields are all optional, it‚Äôll return None for the missing fields:\n\nclass ArticleSpec(BaseModel):\n    \"\"\"Information about an article written in markdown\"\"\"\n\n    title: str = Field(description=\"Article title\")\n    author: str = Field(description=\"Name of the author\")\n    date: str | None = Field(description=\"Date written in YYYY-MM-DD format.\")\n\n\ndata = chat.extract_data(prompt, data_model=ArticleSpec)\nprint(json.dumps(data, indent=2))\n\n{\n  \"title\": \"Structured Data\",\n  \"author\": \"Hadley Wickham\",\n  \"date\": null\n}\n\n\n\n\nData frames\nIf you want to define a data frame like data_model, you might be tempted to create a model like this, where each field is a list of scalar values:\nclass Persons(BaseModel):\n    name: list[str]\n    age: list[int]\nThis however, is not quite right because there‚Äôs no way to specify that each field should have the same length. Instead you need to turn the data structure ‚Äúinside out‚Äù, and instead create an array of objects:\nclass Person(BaseModel):\n    name: str\n    age: int\n\nclass Persons(BaseModel):\n    persons: list[Person]\nIf you‚Äôre familiar with the terms between row-oriented and column-oriented data frames, this is the same idea."
  },
  {
    "objectID": "structured-data.html#token-usage",
    "href": "structured-data.html#token-usage",
    "title": "Structured data",
    "section": "Token usage",
    "text": "Token usage\nBelow is a summary of the tokens used to create the output in this example.\n\nfrom chatlas import token_usage\ntoken_usage()\n\n[{'name': 'OpenAI', 'input': 6081, 'output': 614},\n {'name': 'Anthropic', 'input': 463, 'output': 103}]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\nchatlas \n",
    "section": "",
    "text": "chatlas\nchatlas provides a simple and unified interface across large language model (llm) providers in Python. It helps you prototype faster by abstracting away complexity from common tasks like streaming chat interfaces, tool calling, structured output, and much more. Switching providers is also as easy as changing one line of code, but you can also reach for provider-specific features when you need them. Developer experience is also a key focus of chatlas: typing support, rich console output, and extension points are all included.\n(Looking for something similar to chatlas, but in R? Check out ellmer!)"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "\nchatlas \n",
    "section": "Install",
    "text": "Install\nInstall the latest stable release from PyPI:\npip install -U chatlas\nOr, install the latest development version from GitHub:\npip install -U git+https://github.com/posit-dev/chatlas"
  },
  {
    "objectID": "index.html#model-providers",
    "href": "index.html#model-providers",
    "title": "\nchatlas \n",
    "section": "Model providers",
    "text": "Model providers\nchatlas supports a variety of model providers. See the API reference for more details (like managing credentials) on each provider.\n\nAnthropic (Claude): ChatAnthropic().\nGitHub model marketplace: ChatGithub().\nGoogle (Gemini): ChatGoogle().\nGroq: ChatGroq().\nOllama local models: ChatOllama().\nOpenAI: ChatOpenAI().\nperplexity.ai: ChatPerplexity().\n\nIt also supports the following enterprise cloud providers:\n\nAWS Bedrock: ChatBedrockAnthropic().\nAzure OpenAI: ChatAzureOpenAI().\nDatabricks: ChatDatabricks().\nSnowflake Cortex: ChatSnowflake().\nVertex AI: ChatVertex().\n\nTo use a model provider that isn‚Äôt listed here, you have two options:\n\nIf the model is OpenAI compatible, use ChatOpenAI() with the appropriate base_url and api_key (see ChatGithub for a reference).\nIf you‚Äôre motivated, implement a new provider by subclassing Provider and implementing the required methods."
  },
  {
    "objectID": "index.html#model-choice",
    "href": "index.html#model-choice",
    "title": "\nchatlas \n",
    "section": "Model choice",
    "text": "Model choice\nIf you‚Äôre using chatlas inside your organisation, you‚Äôll be limited to what your org allows, which is likely to be one provided by a big cloud provider (e.g.¬†ChatAzureOpenAI() and ChatBedrockAnthropic()). If you‚Äôre using chatlas for your own personal exploration, you have a lot more freedom so we have a few recommendations to help you get started:\n\nChatOpenAI() or ChatAnthropic() are both good places to start. ChatOpenAI() defaults to GPT-4o, but you can use model = \"gpt-4o-mini\" for a cheaper lower-quality model, or model = \"o1-mini\" for more complex reasoning. ChatAnthropic() is similarly good; it defaults to Claude 3.5 Sonnet which we have found to be particularly good at writing code.\nChatGoogle() is great for large prompts, because it has a much larger context window than other models. It allows up to 1 million tokens, compared to Claude 3.5 Sonnet‚Äôs 200k and GPT-4o‚Äôs 128k.\nChatOllama(), which uses Ollama, allows you to run models on your own computer. The biggest models you can run locally aren‚Äôt as good as the state of the art hosted models, but they also don‚Äôt share your data and and are effectively free."
  },
  {
    "objectID": "index.html#using-chatlas",
    "href": "index.html#using-chatlas",
    "title": "\nchatlas \n",
    "section": "Using chatlas",
    "text": "Using chatlas\nYou can chat via chatlas in several different ways, depending on whether you are working interactively or programmatically. They all start with creating a new chat object:\nfrom chatlas import ChatOpenAI\n\nchat = ChatOpenAI(\n  model = \"gpt-4o\",\n  system_prompt = \"You are a friendly but terse assistant.\",\n)\n\nInteractive console\nFrom a chat instance, it‚Äôs simple to start a web-based or terminal-based chat console, which is great for testing the capabilities of the model. In either case, responses stream in real-time, and context is preserved across turns.\nchat.app()\n\n\n\nOr, if you prefer to work from the terminal:\nchat.console()\nEntering chat console. Press Ctrl+C to quit.\n\n?&gt; Who created Python?\n\nPython was created by Guido van Rossum. He began development in the late 1980s and released the first version in 1991. \n\n?&gt; Where did he develop it?\n\nGuido van Rossum developed Python while working at Centrum Wiskunde & Informatica (CWI) in the Netherlands.     \n\n\nThe .chat() method\nFor a more programmatic approach, you can use the .chat() method to ask a question and get a response. By default, the response prints to a rich console as it streams in:\nchat.chat(\"What preceding languages most influenced Python?\")\nPython was primarily influenced by ABC, with additional inspiration from C,\nModula-3, and various other languages.\nTo ask a question about an image, pass one or more additional input arguments using content_image_file() and/or content_image_url():\nfrom chatlas import content_image_url\n\nchat.chat(\n    content_image_url(\"https://www.python.org/static/img/python-logo.png\"),\n    \"Can you explain this logo?\"\n)\nThe Python logo features two intertwined snakes in yellow and blue,\nrepresenting the Python programming language. The design symbolizes...\nTo get the full response as a string, use the built-in str() function. Optionally, you can also suppress the rich console output by setting echo=\"none\":\nresponse = chat.chat(\"Who is Posit?\", echo=\"none\")\nprint(str(response))\nAs we‚Äôll see in later articles, echo=\"all\" can also be useful for debugging, as it shows additional information, such as tool calls.\n\n\nThe .stream() method\nIf you want to do something with the response in real-time (i.e., as it arrives in chunks), use the .stream() method. This method returns an iterator that yields each chunk of the response as it arrives:\nresponse = chat.stream(\"Who is Posit?\")\nfor chunk in response:\n    print(chunk, end=\"\")\nThe .stream() method can also be useful if you‚Äôre building a chatbot or other programs that needs to display responses as they arrive.\n\n\nTool calling\nTool calling is as simple as passing a function with type hints and docstring to .register_tool().\nimport sys\n\ndef get_current_python_version() -&gt; str:\n    \"\"\"Get the current version of Python.\"\"\"\n    return sys.version\n\nchat.register_tool(get_current_python_version)\nchat.chat(\"What's the current version of Python?\")\nThe current version of Python is 3.13.\nLearn more in the tool calling article\n\n\nStructured data\nStructured data (i.e., structured output) is as simple as passing a pydantic model to .extract_data().\nfrom pydantic import BaseModel\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\nchat.extract_data(\n    \"My name is Susan and I'm 13 years old\", \n    data_model=Person,\n)\n{'name': 'Susan', 'age': 13}\nLearn more in the structured data article\n\n\nMulti-modal input\nAttach images and pdfs when submitting input to using any one of the content_* functions.\nfrom chatlas import content_image_url\n\nchat.chat(\n    content_image_url(\"https://www.python.org/static/img/python-logo.png\"),\n    \"What do you see in this image?\"\n)\nThis image displays the logo of the Python programming language. It features the word \"python\" alongside the distinctive two snake heads logo, which is colored in blue and yellow.  \nLearn more in the content reference pages for more details on the available content types.\n\n\nExport chat\nEasily get a full markdown or HTML export of a conversation:\nchat.export(\"index.html\", title=\"Python Q&A\")\nIf the export doesn‚Äôt have all the information you need, you can also access the full conversation history via the .get_turns() method:\nchat.get_turns()\nAnd, if the conversation is too long, you can specify which turns to include:\nchat.export(\"index.html\", turns=chat.get_turns()[-5:])\n\n\nAsync\nchat methods tend to be synchronous by default, but you can use the async flavor by appending _async to the method name:\nimport asyncio\n\nasync def main():\n    await chat.chat_async(\"What is the capital of France?\")\n\nasyncio.run(main())\n\n\nTyping support\nchatlas has full typing support, meaning that, among other things, autocompletion just works in your favorite editor:\n\n\n\n\n\nTroubleshooting\nSometimes things like token limits, tool errors, or other issues can cause problems that are hard to diagnose. In these cases, the echo=\"all\" option is helpful for getting more information about what‚Äôs going on under the hood.\nchat.chat(\"What is the capital of France?\", echo=\"all\")\nThis shows important information like tool call results, finish reasons, and more.\nIf the problem isn‚Äôt self-evident, you can also reach into the .get_last_turn(), which contains the full response object, with full details about the completion.\n\n\n\nFor monitoring issues in a production (or otherwise non-interactive) environment, you may want to enabling logging. Also, since chatlas builds on top of packages like anthropic and openai, you can also enable their debug logging to get lower-level information, like HTTP requests and response codes.\n$ export CHATLAS_LOG=info\n$ export OPENAI_LOG=info\n$ export ANTHROPIC_LOG=info\n\n\nNext steps\nIf you‚Äôre new to world LLMs, you might want to read the Get Started guide, which covers some basic concepts and terminology.\nOnce you‚Äôre comfortable with the basics, you can explore more in-depth topics like prompt design or the API reference."
  },
  {
    "objectID": "rag.html",
    "href": "rag.html",
    "title": "Retrieval-Augmented Generation (RAG)",
    "section": "",
    "text": "Retrieval-Augmented Generation (RAG) helps LLMs gain the context they need to accurately answer a question. Nowadays, LLMs are trained on a vast amount of data, but they can‚Äôt possibly know everything, especially when it comes to real-time or sensitive information that isn‚Äôt publicly available. In this article, we‚Äôll walk through a simple example of how to leverage RAG in combination with chatlas.\nThe core idea of RAG is fairly simple, yet general: given a set of documents and a user query, find the document(s) that are the most ‚Äúsimilar‚Äù to the query and supply those documents as additional context to the LLM. The LLM can then use this context to generate a response to the user query. There are many ways to measure similarity between a query and a document, but one common approach is to use embeddings. Embeddings are dense, low-dimensional vectors that represent the semantic content of a piece of text. By comparing the embeddings of the query and each document, we can compute a similarity score that tells us how closely related the query is to each document.\nThere are also many different ways to generate embeddings, but one popular method is to use pre-trained models like Sentence Transformers. Different models are trained on different datasets and thus have different strengths and weaknesses, so it‚Äôs worth experimenting with a few to see which one works best for your particular use case. In our example, we‚Äôll use the all-MiniLM-L12-v2 model, which is a popular choice thanks to its balance of speed and accuracy.\n\nfrom sentence_transformers import SentenceTransformer\n\nembed_model = SentenceTransformer(\"sentence-transformers/all-MiniLM-L12-v2\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSupplied with an embedding model, we can now compute embeddings for each document in our set and for a user_query, then compare the query embedding to each document embedding to find the most similar document(s). A common way to measure similarity between two vectors is to compute the cosine similarity. The following code demonstrates how to do this:\n\nimport numpy as np\n\n# Our list of documents (one document per list element)\ndocuments = [\n    \"The Python programming language was created by Guido van Rossum.\",\n    \"Python is known for its simple, readable syntax.\",\n    \"Python supports multiple programming paradigms.\",\n]\n\n# Compute embeddings for each document (do this once for performance reasons)\nembeddings = [embed_model.encode([doc])[0] for doc in documents]\n\n\ndef get_top_k_similar_documents(\n    user_query,\n    documents,\n    embeddings,\n    embed_model,\n    top_k=3,\n):\n    # Compute embedding for the user query\n    query_embedding = embed_model.encode([user_query])[0]\n\n    # Calculate cosine similarity between the query and each document\n    similarities = np.dot(embeddings, query_embedding) / (\n        np.linalg.norm(embeddings, axis=1) * np.linalg.norm(query_embedding)\n    )\n\n    # Get the top-k most similar documents\n    top_indices = np.argsort(similarities)[-top_k:][::-1]\n    return [documents[i] for i in top_indices]\n\n\nuser_query = \"Who created Python?\"\n\ntop_docs = get_top_k_similar_documents(\n    user_query,\n    documents,\n    embeddings,\n    embed_model,\n    top_k=3,\n)\n\nAnd, now that we have the most similar documents, we can supply them to the LLM as context for generating a response to the user query. Here‚Äôs how we might do that using chatlas:\n\nfrom chatlas import ChatAnthropic\n\nchat = ChatAnthropic(\n    system_prompt=\"\"\"\n    You are a helpful AI assistant. Using the provided context, \n    answer the user's question. If you cannot answer the question based on the \n    context, say so.\n\"\"\"\n)\n\n_ = chat.chat(\n    f\"Context: {top_docs}\\nQuestion: {user_query}\"\n)\n\n\n\n\n\nGuido van Rossum created the Python programming language."
  },
  {
    "objectID": "web-apps.html",
    "href": "web-apps.html",
    "title": "chatlas",
    "section": "",
    "text": "In the intro, we learned how the .app() method launches a web app with a simple chat interface, for example:\nThis is a great way to quickly test your model, but you‚Äôll likely want to embed similar functionality into a larger web app. Here‚Äôs how you can do that we different web frameworks."
  },
  {
    "objectID": "web-apps.html#shiny",
    "href": "web-apps.html#shiny",
    "title": "chatlas",
    "section": "Shiny",
    "text": "Shiny\nUsing Shiny‚Äôs ui.Chat component, you can simply pass user input from the component into the chat.stream() method. This generate a response stream that can then be passed to .append_message_stream().\nfrom chatlas import ChatAnthropic\nfrom shiny.express import ui\n\nchat = ui.Chat(\n    id=\"ui_chat\",\n    messages=[\"Hi! How can I help you today?\"],\n)\nchat.ui()\n\nchat_model = ChatAnthropic()\n\n@chat.on_user_submit\nasync def handle_user_input():\n    response = chat_model.stream(chat.user_input())\n    await chat.append_message_stream(response)"
  },
  {
    "objectID": "web-apps.html#streamlit",
    "href": "web-apps.html#streamlit",
    "title": "chatlas",
    "section": "Streamlit",
    "text": "Streamlit\nStreamlit is a popular Python library for building web apps. You can use the st.chat_input() and st.chat_message() methods to create a chat interface. Here‚Äôs an example of how you can use Chatlas with Streamlit:\nimport streamlit as st\nfrom chatlas import ChatOpenAI, Turn\n\nwith st.sidebar:\n    openai_api_key = st.text_input(\n        \"OpenAI API Key\", key=\"chatbot_api_key\", type=\"password\"\n    )\n    \"[Get an OpenAI API key](https://platform.openai.com/account/api-keys)\"\n    \"[View the source code](https://github.com/streamlit/llm-examples/blob/main/Chatbot.py)\"\n\nst.title(\"üí¨ Chatbot\")\n\nif \"turns\" not in st.session_state:\n    st.session_state[\"turns\"] = [\n        Turn(role=\"assistant\", contents=\"How can I help you?\"),\n    ]\n\nturns: list[Turn] = st.session_state.turns\n\nfor turn in turns:\n    st.chat_message(turn.role).write(turn.text)\n\n\nif prompt := st.chat_input():\n    if not openai_api_key:\n        st.info(\"Please add your OpenAI API key to continue.\")\n        st.stop()\n\n    st.chat_message(\"user\").write(prompt)\n\n    chat = ChatOpenAI(api_key=openai_api_key, turns=turns)\n    response = chat.stream(prompt)\n\n    with st.chat_message(\"assistant\"):\n        st.write_stream(response)\n\n    st.session_state[\"turns\"] = chat.get_turns()"
  },
  {
    "objectID": "reference/types.ContentImageRemote.html",
    "href": "reference/types.ContentImageRemote.html",
    "title": "types.ContentImageRemote",
    "section": "",
    "text": "types.ContentImageRemote()\nImage content from a URL.\nThis is the return type for content_image_url. It‚Äôs not meant to be used directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nurl\n\nThe URL of the image.\nrequired\n\n\ndetail\n\nA detail setting for the image. Can be \"auto\", \"low\", or \"high\".\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentImageRemote"
    ]
  },
  {
    "objectID": "reference/types.ContentImageRemote.html#parameters",
    "href": "reference/types.ContentImageRemote.html#parameters",
    "title": "types.ContentImageRemote",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nurl\n\nThe URL of the image.\nrequired\n\n\ndetail\n\nA detail setting for the image. Can be \"auto\", \"low\", or \"high\".\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentImageRemote"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html",
    "href": "reference/ChatGithub.html",
    "title": "ChatGithub",
    "section": "",
    "text": "ChatGithub(\n    system_prompt=None,\n    turns=None,\n    model=None,\n    api_key=None,\n    base_url='https://models.inference.ai.azure.com/',\n    seed=MISSING,\n    kwargs=None,\n)\nChat with a model hosted on the GitHub model marketplace.\nGitHub (via Azure) hosts a wide variety of open source models, some of which are fined tuned for specific tasks.\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nSign up at https://github.com/marketplace/models to get an API key. You may need to apply for and be accepted into a beta access program.\n\n\n\n\n\nimport os\nfrom chatlas import ChatGithub\n\nchat = ChatGithub(api_key=os.getenv(\"GITHUB_PAT\"))\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the GITHUB_PAT environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses Github‚Äôs API.\n'https://models.inference.ai.azure.com/'\n\n\nseed\nOptional[int] | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.\n\n\n\n\n\n\nThis function is a lightweight wrapper around ChatOpenAI with the defaults tweaked for the GitHub model marketplace.\n\n\n\nPasting an API key into a chat constructor (e.g., ChatGithub(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nGITHUB_PAT=...\nfrom chatlas import ChatGithub\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatGithub()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport GITHUB_PAT=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html#prerequisites",
    "href": "reference/ChatGithub.html#prerequisites",
    "title": "ChatGithub",
    "section": "",
    "text": "API key\n\n\n\nSign up at https://github.com/marketplace/models to get an API key. You may need to apply for and be accepted into a beta access program.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html#examples",
    "href": "reference/ChatGithub.html#examples",
    "title": "ChatGithub",
    "section": "",
    "text": "import os\nfrom chatlas import ChatGithub\n\nchat = ChatGithub(api_key=os.getenv(\"GITHUB_PAT\"))\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html#parameters",
    "href": "reference/ChatGithub.html#parameters",
    "title": "ChatGithub",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the GITHUB_PAT environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses Github‚Äôs API.\n'https://models.inference.ai.azure.com/'\n\n\nseed\nOptional[int] | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html#returns",
    "href": "reference/ChatGithub.html#returns",
    "title": "ChatGithub",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html#note",
    "href": "reference/ChatGithub.html#note",
    "title": "ChatGithub",
    "section": "",
    "text": "This function is a lightweight wrapper around ChatOpenAI with the defaults tweaked for the GitHub model marketplace.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/ChatGithub.html#note-1",
    "href": "reference/ChatGithub.html#note-1",
    "title": "ChatGithub",
    "section": "",
    "text": "Pasting an API key into a chat constructor (e.g., ChatGithub(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nGITHUB_PAT=...\nfrom chatlas import ChatGithub\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatGithub()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport GITHUB_PAT=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGithub"
    ]
  },
  {
    "objectID": "reference/types.ContentJson.html",
    "href": "reference/types.ContentJson.html",
    "title": "types.ContentJson",
    "section": "",
    "text": "types.ContentJson()\nJSON content\nThis content type primarily exists to signal structured data extraction (i.e., data extracted via Chat‚Äôs .extract_data() method)\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\n\nThe JSON data extracted\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentJson"
    ]
  },
  {
    "objectID": "reference/types.ContentJson.html#parameters",
    "href": "reference/types.ContentJson.html#parameters",
    "title": "types.ContentJson",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nvalue\n\nThe JSON data extracted\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentJson"
    ]
  },
  {
    "objectID": "reference/ChatAzureOpenAI.html",
    "href": "reference/ChatAzureOpenAI.html",
    "title": "ChatAzureOpenAI",
    "section": "",
    "text": "ChatAzureOpenAI(\n    endpoint,\n    deployment_id,\n    api_version,\n    api_key=None,\n    system_prompt=None,\n    turns=None,\n    seed=MISSING,\n    kwargs=None,\n)\nChat with a model hosted on Azure OpenAI.\nThe Azure OpenAI server hosts a number of open source models as well as proprietary models from OpenAI.\n\n\nimport os\nfrom chatlas import ChatAzureOpenAI\n\nchat = ChatAzureOpenAI(\n    endpoint=os.getenv(\"AZURE_OPENAI_ENDPOINT\"),\n    deployment_id=\"REPLACE_WITH_YOUR_DEPLOYMENT_ID\",\n    api_version=\"YYYY-MM-DD\",\n    api_key=os.getenv(\"AZURE_OPENAI_API_KEY\"),\n)\n\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nendpoint\nstr\nAzure OpenAI endpoint url with protocol and hostname, i.e.¬†https://{your-resource-name}.openai.azure.com. Defaults to using the value of the AZURE_OPENAI_ENDPOINT envinronment variable.\nrequired\n\n\ndeployment_id\nstr\nDeployment id for the model you want to use.\nrequired\n\n\napi_version\nstr\nThe API version to use.\nrequired\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the AZURE_OPENAI_API_KEY environment variable.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nseed\nint | None | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatAzureClientArgs']\nAdditional arguments to pass to the openai.AzureOpenAI() client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAzureOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatAzureOpenAI.html#examples",
    "href": "reference/ChatAzureOpenAI.html#examples",
    "title": "ChatAzureOpenAI",
    "section": "",
    "text": "import os\nfrom chatlas import ChatAzureOpenAI\n\nchat = ChatAzureOpenAI(\n    endpoint=os.getenv(\"AZURE_OPENAI_ENDPOINT\"),\n    deployment_id=\"REPLACE_WITH_YOUR_DEPLOYMENT_ID\",\n    api_version=\"YYYY-MM-DD\",\n    api_key=os.getenv(\"AZURE_OPENAI_API_KEY\"),\n)\n\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAzureOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatAzureOpenAI.html#parameters",
    "href": "reference/ChatAzureOpenAI.html#parameters",
    "title": "ChatAzureOpenAI",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nendpoint\nstr\nAzure OpenAI endpoint url with protocol and hostname, i.e.¬†https://{your-resource-name}.openai.azure.com. Defaults to using the value of the AZURE_OPENAI_ENDPOINT envinronment variable.\nrequired\n\n\ndeployment_id\nstr\nDeployment id for the model you want to use.\nrequired\n\n\napi_version\nstr\nThe API version to use.\nrequired\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the AZURE_OPENAI_API_KEY environment variable.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nseed\nint | None | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatAzureClientArgs']\nAdditional arguments to pass to the openai.AzureOpenAI() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAzureOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatAzureOpenAI.html#returns",
    "href": "reference/ChatAzureOpenAI.html#returns",
    "title": "ChatAzureOpenAI",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAzureOpenAI"
    ]
  },
  {
    "objectID": "reference/types.Content.html",
    "href": "reference/types.Content.html",
    "title": "types.Content",
    "section": "",
    "text": "types.Content\ntypes.Content()\nBase class for all content types that can be appear in a Turn",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.Content"
    ]
  },
  {
    "objectID": "reference/Tool.html",
    "href": "reference/Tool.html",
    "title": "Tool",
    "section": "",
    "text": "Tool(func, *, model=None)\nDefine a tool\nDefine a Python function for use by a chatbot. The function will always be invoked in the current Python process.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfunc\nCallable[‚Ä¶, Any] | Callable[‚Ä¶, Awaitable[Any]]\nThe function to be invoked when the tool is called.\nrequired\n\n\nmodel\nOptional[type[BaseModel]]\nA Pydantic model that describes the input parameters for the function. If not provided, the model will be inferred from the function‚Äôs type hints. The primary reason why you might want to provide a model in Note that the name and docstring of the model takes precedence over the name and docstring of the function.\nNone",
    "crumbs": [
      "Reference",
      "Tool calling",
      "Tool"
    ]
  },
  {
    "objectID": "reference/Tool.html#parameters",
    "href": "reference/Tool.html#parameters",
    "title": "Tool",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfunc\nCallable[‚Ä¶, Any] | Callable[‚Ä¶, Awaitable[Any]]\nThe function to be invoked when the tool is called.\nrequired\n\n\nmodel\nOptional[type[BaseModel]]\nA Pydantic model that describes the input parameters for the function. If not provided, the model will be inferred from the function‚Äôs type hints. The primary reason why you might want to provide a model in Note that the name and docstring of the model takes precedence over the name and docstring of the function.\nNone",
    "crumbs": [
      "Reference",
      "Tool calling",
      "Tool"
    ]
  },
  {
    "objectID": "reference/image_url.html",
    "href": "reference/image_url.html",
    "title": "content_image_url",
    "section": "",
    "text": "content_image_url(url, detail='auto')\nEncode image content from a URL for chat input.\nThis function is used to prepare image URLs for input to the chatbot. It can handle both regular URLs and data URLs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nThe URL of the image to include in the chat input. Can be a data: URL or a regular URL.\nrequired\n\n\ndetail\nLiteral['auto', 'low', 'high']\nThe detail setting for this image. Can be \"auto\", \"low\", or \"high\".\n'auto'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.\n\n\n\n\n\n\nfrom chatlas import ChatOpenAI, content_image_url\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_url(\"https://www.python.org/static/img/python-logo.png\"),\n)\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the URL is not valid or the detail setting is invalid."
  },
  {
    "objectID": "reference/image_url.html#parameters",
    "href": "reference/image_url.html#parameters",
    "title": "content_image_url",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nThe URL of the image to include in the chat input. Can be a data: URL or a regular URL.\nrequired\n\n\ndetail\nLiteral['auto', 'low', 'high']\nThe detail setting for this image. Can be \"auto\", \"low\", or \"high\".\n'auto'"
  },
  {
    "objectID": "reference/image_url.html#returns",
    "href": "reference/image_url.html#returns",
    "title": "content_image_url",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object."
  },
  {
    "objectID": "reference/image_url.html#examples",
    "href": "reference/image_url.html#examples",
    "title": "content_image_url",
    "section": "",
    "text": "from chatlas import ChatOpenAI, content_image_url\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_url(\"https://www.python.org/static/img/python-logo.png\"),\n)"
  },
  {
    "objectID": "reference/image_url.html#raises",
    "href": "reference/image_url.html#raises",
    "title": "content_image_url",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf the URL is not valid or the detail setting is invalid."
  },
  {
    "objectID": "reference/ChatSnowflake.html",
    "href": "reference/ChatSnowflake.html",
    "title": "ChatSnowflake",
    "section": "",
    "text": "ChatSnowflake(\n    system_prompt=None,\n    model=None,\n    turns=None,\n    connection_name=None,\n    account=None,\n    user=None,\n    password=None,\n    private_key_file=None,\n    private_key_file_pwd=None,\n    kwargs=None,\n)\nChat with a Snowflake Cortex LLM\nhttps://docs.snowflake.com/en/user-guide/snowflake-cortex/llm-functions\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatSnowflake, requires the snowflake-ml-python package: pip install \"chatlas[snowflake]\".\n\n\n\n\n\n\n\n\nSnowflake credentials\n\n\n\nSnowflake provides a handful of ways to authenticate, but it‚Äôs recommended to use key-pair auth to generate a private_key_file. It‚Äôs also recommended to place your credentials in a connections.toml file.\nThis way, once your credentials are in the connections.toml file, you can simply call ChatSnowflake(connection_name=\"my_connection\") to authenticate. If you don‚Äôt want to use a connections.toml file, you can specify the connection parameters directly (with account, user, password, etc.).\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nconnection_name\nOptional[str]\nThe name of the connection (i.e., section) within the connections.toml file. This is useful if you want to keep your credentials in a connections.toml file rather than specifying them directly in the arguments. https://docs.snowflake.com/en/developer-guide/snowpark/python/creating-session#connect-by-using-the-connections-toml-file\nNone\n\n\naccount\nOptional[str]\nYour Snowflake account identifier. Required if connection_name is not provided. https://docs.snowflake.com/en/user-guide/admin-account-identifier\nNone\n\n\nuser\nOptional[str]\nYour Snowflake user name. Required if connection_name is not provided.\nNone\n\n\npassword\nOptional[str]\nYour Snowflake password. Required if doing password authentication and connection_name is not provided.\nNone\n\n\nprivate_key_file\nOptional[str]\nThe path to your private key file. Required if you are using key pair authentication. https://docs.snowflake.com/en/user-guide/key-pair-auth\nNone\n\n\nprivate_key_file_pwd\nOptional[str]\nThe password for your private key file. Required if you are using key pair authentication. https://docs.snowflake.com/en/user-guide/key-pair-auth\nNone\n\n\nkwargs\nOptional[dict[str, str | int]]\nAdditional keyword arguments passed along to the Snowflake connection builder. These can include any parameters supported by the snowflake-ml-python package. https://docs.snowflake.com/en/developer-guide/snowpark/python/creating-session#connect-by-specifying-connection-parameters\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatSnowflake"
    ]
  },
  {
    "objectID": "reference/ChatSnowflake.html#prerequisites",
    "href": "reference/ChatSnowflake.html#prerequisites",
    "title": "ChatSnowflake",
    "section": "",
    "text": "Python requirements\n\n\n\nChatSnowflake, requires the snowflake-ml-python package: pip install \"chatlas[snowflake]\".\n\n\n\n\n\n\n\n\nSnowflake credentials\n\n\n\nSnowflake provides a handful of ways to authenticate, but it‚Äôs recommended to use key-pair auth to generate a private_key_file. It‚Äôs also recommended to place your credentials in a connections.toml file.\nThis way, once your credentials are in the connections.toml file, you can simply call ChatSnowflake(connection_name=\"my_connection\") to authenticate. If you don‚Äôt want to use a connections.toml file, you can specify the connection parameters directly (with account, user, password, etc.).",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatSnowflake"
    ]
  },
  {
    "objectID": "reference/ChatSnowflake.html#parameters",
    "href": "reference/ChatSnowflake.html#parameters",
    "title": "ChatSnowflake",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nconnection_name\nOptional[str]\nThe name of the connection (i.e., section) within the connections.toml file. This is useful if you want to keep your credentials in a connections.toml file rather than specifying them directly in the arguments. https://docs.snowflake.com/en/developer-guide/snowpark/python/creating-session#connect-by-using-the-connections-toml-file\nNone\n\n\naccount\nOptional[str]\nYour Snowflake account identifier. Required if connection_name is not provided. https://docs.snowflake.com/en/user-guide/admin-account-identifier\nNone\n\n\nuser\nOptional[str]\nYour Snowflake user name. Required if connection_name is not provided.\nNone\n\n\npassword\nOptional[str]\nYour Snowflake password. Required if doing password authentication and connection_name is not provided.\nNone\n\n\nprivate_key_file\nOptional[str]\nThe path to your private key file. Required if you are using key pair authentication. https://docs.snowflake.com/en/user-guide/key-pair-auth\nNone\n\n\nprivate_key_file_pwd\nOptional[str]\nThe password for your private key file. Required if you are using key pair authentication. https://docs.snowflake.com/en/user-guide/key-pair-auth\nNone\n\n\nkwargs\nOptional[dict[str, str | int]]\nAdditional keyword arguments passed along to the Snowflake connection builder. These can include any parameters supported by the snowflake-ml-python package. https://docs.snowflake.com/en/developer-guide/snowpark/python/creating-session#connect-by-specifying-connection-parameters\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatSnowflake"
    ]
  },
  {
    "objectID": "reference/ChatVertex.html",
    "href": "reference/ChatVertex.html",
    "title": "ChatVertex",
    "section": "",
    "text": "ChatVertex(\n    model=None,\n    project=None,\n    location=None,\n    api_key=None,\n    system_prompt=None,\n    turns=None,\n    kwargs=None,\n)\nChat with a Google Vertex AI model.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatGoogle requires the google-genai package: pip install \"chatlas[vertex]\".\n\n\n\n\n\n\n\n\nCredentials\n\n\n\nTo use Google‚Äôs models (i.e., Vertex AI), you‚Äôll need to sign up for an account with Vertex AI, then specify the appropriate model, project, and location.\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\nproject\nOptional[str]\nThe Google Cloud project ID (e.g., ‚Äúyour-project-id‚Äù). If not provided, the GOOGLE_CLOUD_PROJECT environment variable will be used.\nNone\n\n\nlocation\nOptional[str]\nThe Google Cloud location (e.g., ‚Äúus-central1‚Äù). If not provided, the GOOGLE_CLOUD_LOCATION environment variable will be used.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.\n\n\n\n\n\n\nimport os\nfrom chatlas import ChatVertex\n\nchat = ChatVertex(\n    project=\"your-project-id\",\n    location=\"us-central1\",\n)\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatVertex"
    ]
  },
  {
    "objectID": "reference/ChatVertex.html#prerequisites",
    "href": "reference/ChatVertex.html#prerequisites",
    "title": "ChatVertex",
    "section": "",
    "text": "Python requirements\n\n\n\nChatGoogle requires the google-genai package: pip install \"chatlas[vertex]\".\n\n\n\n\n\n\n\n\nCredentials\n\n\n\nTo use Google‚Äôs models (i.e., Vertex AI), you‚Äôll need to sign up for an account with Vertex AI, then specify the appropriate model, project, and location.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatVertex"
    ]
  },
  {
    "objectID": "reference/ChatVertex.html#parameters",
    "href": "reference/ChatVertex.html#parameters",
    "title": "ChatVertex",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\nproject\nOptional[str]\nThe Google Cloud project ID (e.g., ‚Äúyour-project-id‚Äù). If not provided, the GOOGLE_CLOUD_PROJECT environment variable will be used.\nNone\n\n\nlocation\nOptional[str]\nThe Google Cloud location (e.g., ‚Äúus-central1‚Äù). If not provided, the GOOGLE_CLOUD_LOCATION environment variable will be used.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatVertex"
    ]
  },
  {
    "objectID": "reference/ChatVertex.html#returns",
    "href": "reference/ChatVertex.html#returns",
    "title": "ChatVertex",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatVertex"
    ]
  },
  {
    "objectID": "reference/ChatVertex.html#examples",
    "href": "reference/ChatVertex.html#examples",
    "title": "ChatVertex",
    "section": "",
    "text": "import os\nfrom chatlas import ChatVertex\n\nchat = ChatVertex(\n    project=\"your-project-id\",\n    location=\"us-central1\",\n)\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatVertex"
    ]
  },
  {
    "objectID": "reference/interpolate.html",
    "href": "reference/interpolate.html",
    "title": "interpolate",
    "section": "",
    "text": "interpolate(prompt, *, variables=None, variable_start='{{', variable_end='}}')\nInterpolate variables into a prompt\nThis is a light-weight wrapper around the Jinja2 templating engine, making it easier to interpolate dynamic data into a prompt template. Compared to f-strings, which expects you to wrap dynamic values in { }, this function expects { } instead, making it easier to include Python code and JSON in your prompt.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprompt\nstr\nThe prompt to interpolate (as a string).\nrequired\n\n\nvariables\nOptional[dict[str, Any]]\nA dictionary of variables to interpolate into the prompt. If not provided, the caller‚Äôs global and local variables are used.\nNone\n\n\nvariable_start\nstr\nThe string that marks the beginning of a variable.\n'{{'\n\n\nvariable_end\nstr\nThe string that marks the end of a variable.\n'}}'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe prompt with variables interpolated.\n\n\n\n\n\n\nfrom chatlas import interpolate\n\nx = 1\ninterpolate(\"The value of `x` is: {{ x }}\")",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate"
    ]
  },
  {
    "objectID": "reference/interpolate.html#parameters",
    "href": "reference/interpolate.html#parameters",
    "title": "interpolate",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nprompt\nstr\nThe prompt to interpolate (as a string).\nrequired\n\n\nvariables\nOptional[dict[str, Any]]\nA dictionary of variables to interpolate into the prompt. If not provided, the caller‚Äôs global and local variables are used.\nNone\n\n\nvariable_start\nstr\nThe string that marks the beginning of a variable.\n'{{'\n\n\nvariable_end\nstr\nThe string that marks the end of a variable.\n'}}'",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate"
    ]
  },
  {
    "objectID": "reference/interpolate.html#returns",
    "href": "reference/interpolate.html#returns",
    "title": "interpolate",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nstr\nThe prompt with variables interpolated.",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate"
    ]
  },
  {
    "objectID": "reference/interpolate.html#examples",
    "href": "reference/interpolate.html#examples",
    "title": "interpolate",
    "section": "",
    "text": "from chatlas import interpolate\n\nx = 1\ninterpolate(\"The value of `x` is: {{ x }}\")",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate"
    ]
  },
  {
    "objectID": "reference/ChatAnthropic.html",
    "href": "reference/ChatAnthropic.html",
    "title": "ChatAnthropic",
    "section": "",
    "text": "ChatAnthropic(\n    system_prompt=None,\n    turns=None,\n    model=None,\n    api_key=None,\n    max_tokens=4096,\n    kwargs=None,\n)\nChat with an Anthropic Claude model.\nAnthropic provides a number of chat based models under the Claude moniker.\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nNote that a Claude Pro membership does not give you the ability to call models via the API. You will need to go to the developer console to sign up (and pay for) a developer account that will give you an API key that you can use with this package.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatAnthropic requires the anthropic package: pip install \"chatlas[anthropic]\".\n\n\n\n\n\nimport os\nfrom chatlas import ChatAnthropic\n\nchat = ChatAnthropic(api_key=os.getenv(\"ANTHROPIC_API_KEY\"))\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\n'Optional[ModelParam]'\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the ANTHROPIC_API_KEY environment variable.\nNone\n\n\nmax_tokens\nint\nMaximum number of tokens to generate before stopping.\n4096\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the anthropic.Anthropic() client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.\n\n\n\n\n\n\nPasting an API key into a chat constructor (e.g., ChatAnthropic(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nANTHROPIC_API_KEY=...\nfrom chatlas import ChatAnthropic\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatAnthropic()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport ANTHROPIC_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatAnthropic.html#prerequisites",
    "href": "reference/ChatAnthropic.html#prerequisites",
    "title": "ChatAnthropic",
    "section": "",
    "text": "API key\n\n\n\nNote that a Claude Pro membership does not give you the ability to call models via the API. You will need to go to the developer console to sign up (and pay for) a developer account that will give you an API key that you can use with this package.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatAnthropic requires the anthropic package: pip install \"chatlas[anthropic]\".",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatAnthropic.html#examples",
    "href": "reference/ChatAnthropic.html#examples",
    "title": "ChatAnthropic",
    "section": "",
    "text": "import os\nfrom chatlas import ChatAnthropic\n\nchat = ChatAnthropic(api_key=os.getenv(\"ANTHROPIC_API_KEY\"))\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatAnthropic.html#parameters",
    "href": "reference/ChatAnthropic.html#parameters",
    "title": "ChatAnthropic",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\n'Optional[ModelParam]'\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the ANTHROPIC_API_KEY environment variable.\nNone\n\n\nmax_tokens\nint\nMaximum number of tokens to generate before stopping.\n4096\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the anthropic.Anthropic() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatAnthropic.html#returns",
    "href": "reference/ChatAnthropic.html#returns",
    "title": "ChatAnthropic",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatAnthropic.html#note",
    "href": "reference/ChatAnthropic.html#note",
    "title": "ChatAnthropic",
    "section": "",
    "text": "Pasting an API key into a chat constructor (e.g., ChatAnthropic(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nANTHROPIC_API_KEY=...\nfrom chatlas import ChatAnthropic\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatAnthropic()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport ANTHROPIC_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAnthropic"
    ]
  },
  {
    "objectID": "reference/types.ChatResponseAsync.html",
    "href": "reference/types.ChatResponseAsync.html",
    "title": "types.ChatResponseAsync",
    "section": "",
    "text": "types.ChatResponseAsync(generator)\nChat response (async) object.\nAn object that, when displayed, will simulatenously consume (if not already consumed) and display the response in a streaming fashion.\nThis is useful for interactive use: if the object is displayed, it can be viewed as it is being generated. And, if the object is not displayed, it can act like an iterator that can be consumed by something else.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncontent\nstr\nThe content of the chat response.\n\n\n\n\n\n\nconsumed Whether the response has been consumed. If the response has been fully consumed, then it can no longer be iterated over, but the content can still be retrieved (via the content attribute).\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_content\nGet the chat response content as a string.\n\n\n\n\n\ntypes.ChatResponseAsync.get_content()\nGet the chat response content as a string.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponseAsync"
    ]
  },
  {
    "objectID": "reference/types.ChatResponseAsync.html#attributes",
    "href": "reference/types.ChatResponseAsync.html#attributes",
    "title": "types.ChatResponseAsync",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ncontent\nstr\nThe content of the chat response.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponseAsync"
    ]
  },
  {
    "objectID": "reference/types.ChatResponseAsync.html#properties",
    "href": "reference/types.ChatResponseAsync.html#properties",
    "title": "types.ChatResponseAsync",
    "section": "",
    "text": "consumed Whether the response has been consumed. If the response has been fully consumed, then it can no longer be iterated over, but the content can still be retrieved (via the content attribute).",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponseAsync"
    ]
  },
  {
    "objectID": "reference/types.ChatResponseAsync.html#methods",
    "href": "reference/types.ChatResponseAsync.html#methods",
    "title": "types.ChatResponseAsync",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_content\nGet the chat response content as a string.\n\n\n\n\n\ntypes.ChatResponseAsync.get_content()\nGet the chat response content as a string.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponseAsync"
    ]
  },
  {
    "objectID": "reference/Provider.html",
    "href": "reference/Provider.html",
    "title": "Provider",
    "section": "",
    "text": "Provider\nProvider()\nA model provider interface for a Chat.\nThis abstract class defines the interface a model provider must implement in order to be used with a Chat instance. The provider is responsible for performing the actual chat completion, and for handling the streaming of the completion results.\nNote that this class is exposed for developers who wish to implement their own provider. In general, you should not need to interact with this class directly.",
    "crumbs": [
      "Reference",
      "Implement a model provider",
      "Provider"
    ]
  },
  {
    "objectID": "reference/content_image_url.html",
    "href": "reference/content_image_url.html",
    "title": "content_image_url",
    "section": "",
    "text": "content_image_url(url, detail='auto')\nEncode image content from a URL for chat input.\nThis function is used to prepare image URLs for input to the chatbot. It can handle both regular URLs and data URLs.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nThe URL of the image to include in the chat input. Can be a data: URL or a regular URL.\nrequired\n\n\ndetail\nLiteral['auto', 'low', 'high']\nThe detail setting for this image. Can be \"auto\", \"low\", or \"high\".\n'auto'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.\n\n\n\n\n\n\nfrom chatlas import ChatOpenAI, content_image_url\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_url(\"https://www.python.org/static/img/python-logo.png\"),\n)\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the URL is not valid or the detail setting is invalid.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_url"
    ]
  },
  {
    "objectID": "reference/content_image_url.html#parameters",
    "href": "reference/content_image_url.html#parameters",
    "title": "content_image_url",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nThe URL of the image to include in the chat input. Can be a data: URL or a regular URL.\nrequired\n\n\ndetail\nLiteral['auto', 'low', 'high']\nThe detail setting for this image. Can be \"auto\", \"low\", or \"high\".\n'auto'",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_url"
    ]
  },
  {
    "objectID": "reference/content_image_url.html#returns",
    "href": "reference/content_image_url.html#returns",
    "title": "content_image_url",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_url"
    ]
  },
  {
    "objectID": "reference/content_image_url.html#examples",
    "href": "reference/content_image_url.html#examples",
    "title": "content_image_url",
    "section": "",
    "text": "from chatlas import ChatOpenAI, content_image_url\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_url(\"https://www.python.org/static/img/python-logo.png\"),\n)",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_url"
    ]
  },
  {
    "objectID": "reference/content_image_url.html#raises",
    "href": "reference/content_image_url.html#raises",
    "title": "content_image_url",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf the URL is not valid or the detail setting is invalid.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_url"
    ]
  },
  {
    "objectID": "reference/types.ContentImageInline.html",
    "href": "reference/types.ContentImageInline.html",
    "title": "types.ContentImageInline",
    "section": "",
    "text": "types.ContentImageInline()\nInline image content.\nThis is the return type for content_image_file and content_image_plot. It‚Äôs not meant to be used directly.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nimage_content_type\n\nThe content type of the image.\nrequired\n\n\ndata\n\nThe base64-encoded image data.\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentImageInline"
    ]
  },
  {
    "objectID": "reference/types.ContentImageInline.html#parameters",
    "href": "reference/types.ContentImageInline.html#parameters",
    "title": "types.ContentImageInline",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nimage_content_type\n\nThe content type of the image.\nrequired\n\n\ndata\n\nThe base64-encoded image data.\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentImageInline"
    ]
  },
  {
    "objectID": "reference/Turn.html",
    "href": "reference/Turn.html",
    "title": "Turn",
    "section": "",
    "text": "Turn(\n    role,\n    contents,\n    *,\n    tokens=None,\n    finish_reason=None,\n    completion=None,\n    **kwargs,\n)\nA user or assistant turn\nEvery conversation with a chatbot consists of pairs of user and assistant turns, corresponding to an HTTP request and response. These turns are represented by the Turn object, which contains a list of Contents representing the individual messages within the turn. These might be text, images, tool requests (assistant only), or tool responses (user only).\nNote that a call to .chat() and related functions may result in multiple user-assistant turn cycles. For example, if you have registered tools, chatlas will automatically handle the tool calling loop, which may result in any number of additional cycles.\n\n\nfrom chatlas import Turn, ChatOpenAI, ChatAnthropic\n\nchat = ChatOpenAI()\nstr(chat.chat(\"What is the capital of France?\"))\nturns = chat.get_turns()\nassert len(turns) == 2\nassert isinstance(turns[0], Turn)\nassert turns[0].role == \"user\"\nassert turns[1].role == \"assistant\"\n\n# Load context into a new chat instance\nchat2 = ChatAnthropic(turns=turns)\nturns2 = chat2.get_turns()\nassert turns == turns2\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrole\nLiteral['user', 'assistant', 'system']\nEither ‚Äúuser‚Äù, ‚Äúassistant‚Äù, or ‚Äúsystem‚Äù.\nrequired\n\n\ncontents\nstr | Sequence[Content | str]\nA list of Content objects.\nrequired\n\n\ntokens\nOptional[tuple[int, int]]\nA numeric vector of length 2 representing the number of input and output tokens (respectively) used in this turn. Currently only recorded for assistant turns.\nNone\n\n\nfinish_reason\nOptional[str]\nA string indicating the reason why the conversation ended. This is only relevant for assistant turns.\nNone\n\n\ncompletion\nOptional[CompletionT]\nThe completion object returned by the provider. This is useful if there‚Äôs information returned by the provider that chatlas doesn‚Äôt otherwise expose. This is only relevant for assistant turns.\nNone",
    "crumbs": [
      "Reference",
      "Turns",
      "Turn"
    ]
  },
  {
    "objectID": "reference/Turn.html#examples",
    "href": "reference/Turn.html#examples",
    "title": "Turn",
    "section": "",
    "text": "from chatlas import Turn, ChatOpenAI, ChatAnthropic\n\nchat = ChatOpenAI()\nstr(chat.chat(\"What is the capital of France?\"))\nturns = chat.get_turns()\nassert len(turns) == 2\nassert isinstance(turns[0], Turn)\nassert turns[0].role == \"user\"\nassert turns[1].role == \"assistant\"\n\n# Load context into a new chat instance\nchat2 = ChatAnthropic(turns=turns)\nturns2 = chat2.get_turns()\nassert turns == turns2",
    "crumbs": [
      "Reference",
      "Turns",
      "Turn"
    ]
  },
  {
    "objectID": "reference/Turn.html#parameters",
    "href": "reference/Turn.html#parameters",
    "title": "Turn",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nrole\nLiteral['user', 'assistant', 'system']\nEither ‚Äúuser‚Äù, ‚Äúassistant‚Äù, or ‚Äúsystem‚Äù.\nrequired\n\n\ncontents\nstr | Sequence[Content | str]\nA list of Content objects.\nrequired\n\n\ntokens\nOptional[tuple[int, int]]\nA numeric vector of length 2 representing the number of input and output tokens (respectively) used in this turn. Currently only recorded for assistant turns.\nNone\n\n\nfinish_reason\nOptional[str]\nA string indicating the reason why the conversation ended. This is only relevant for assistant turns.\nNone\n\n\ncompletion\nOptional[CompletionT]\nThe completion object returned by the provider. This is useful if there‚Äôs information returned by the provider that chatlas doesn‚Äôt otherwise expose. This is only relevant for assistant turns.\nNone",
    "crumbs": [
      "Reference",
      "Turns",
      "Turn"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Start a chat with a particular large language model (llm) provider.\n\n\n\nChatAnthropic\nChat with an Anthropic Claude model.\n\n\nChatAuto\nUse environment variables (env vars) to configure the Chat provider and model.\n\n\nChatAzureOpenAI\nChat with a model hosted on Azure OpenAI.\n\n\nChatBedrockAnthropic\nChat with an AWS bedrock model.\n\n\nChatDatabricks\nChat with a model hosted on Databricks.\n\n\nChatGithub\nChat with a model hosted on the GitHub model marketplace.\n\n\nChatGoogle\nChat with a Google Gemini model.\n\n\nChatGroq\nChat with a model hosted on Groq.\n\n\nChatOllama\nChat with a local Ollama model.\n\n\nChatOpenAI\nChat with an OpenAI model.\n\n\nChatPerplexity\nChat with a model hosted on perplexity.ai.\n\n\nChatSnowflake\nChat with a Snowflake Cortex LLM\n\n\nChatVertex\nChat with a Google Vertex AI model.\n\n\n\n\n\n\nMethods and attributes available on a chat instance\n\n\n\nChat\nA chat object that can be used to interact with a language model.\n\n\n\n\n\n\nSubmit image input to the chat\n\n\n\ncontent_image_file\nEncode image content from a file for chat input.\n\n\ncontent_image_plot\nEncode the current matplotlib plot as an image for chat input.\n\n\ncontent_image_url\nEncode image content from a URL for chat input.\n\n\n\n\n\n\nSubmit pdf input to the chat\n\n\n\ncontent_pdf_file\nPrepare a local PDF for input to a chat.\n\n\ncontent_pdf_url\nUse a remote PDF for input to a chat.\n\n\n\n\n\n\nInterpolate variables into prompt templates\n\n\n\ninterpolate\nInterpolate variables into a prompt\n\n\ninterpolate_file\nInterpolate variables into a prompt from a file\n\n\n\n\n\n\nAdd context to python function before registering it as a tool.\n\n\n\nTool\nDefine a tool\n\n\nToolRejectError\nError to represent a tool call being rejected.\n\n\n\n\n\n\nA provider-agnostic representation of content generated during an assistant/user turn.\n\n\n\nTurn\nA user or assistant turn\n\n\n\n\n\n\n\n\n\ntoken_usage\nReport on token usage in the current session\n\n\n\n\n\n\n\n\n\nProvider\nA model provider interface for a Chat.\n\n\n\n\n\n\n\n\n\ntypes.Content\nBase class for all content types that can be appear in a Turn\n\n\ntypes.ContentImage\nBase class for image content.\n\n\ntypes.ContentImageInline\nInline image content.\n\n\ntypes.ContentImageRemote\nImage content from a URL.\n\n\ntypes.ContentJson\nJSON content\n\n\ntypes.ContentText\nText content for a Turn\n\n\ntypes.ContentToolRequest\nA request to call a tool/function\n\n\ntypes.ContentToolResult\nThe result of calling a tool/function\n\n\ntypes.ChatResponse\nChat response object.\n\n\ntypes.ChatResponseAsync\nChat response (async) object.\n\n\ntypes.ImageContentTypes\nAllowable content types for images.\n\n\ntypes.MISSING_TYPE\nA singleton representing a missing value.\n\n\ntypes.MISSING\n\n\n\ntypes.SubmitInputArgsT\nA TypedDict representing the arguments that can be passed to the .chat()\n\n\ntypes.TokenUsage\nToken usage for a given provider (name).",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#chat-model-providers",
    "href": "reference/index.html#chat-model-providers",
    "title": "Function reference",
    "section": "",
    "text": "Start a chat with a particular large language model (llm) provider.\n\n\n\nChatAnthropic\nChat with an Anthropic Claude model.\n\n\nChatAuto\nUse environment variables (env vars) to configure the Chat provider and model.\n\n\nChatAzureOpenAI\nChat with a model hosted on Azure OpenAI.\n\n\nChatBedrockAnthropic\nChat with an AWS bedrock model.\n\n\nChatDatabricks\nChat with a model hosted on Databricks.\n\n\nChatGithub\nChat with a model hosted on the GitHub model marketplace.\n\n\nChatGoogle\nChat with a Google Gemini model.\n\n\nChatGroq\nChat with a model hosted on Groq.\n\n\nChatOllama\nChat with a local Ollama model.\n\n\nChatOpenAI\nChat with an OpenAI model.\n\n\nChatPerplexity\nChat with a model hosted on perplexity.ai.\n\n\nChatSnowflake\nChat with a Snowflake Cortex LLM\n\n\nChatVertex\nChat with a Google Vertex AI model.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#the-chat-object",
    "href": "reference/index.html#the-chat-object",
    "title": "Function reference",
    "section": "",
    "text": "Methods and attributes available on a chat instance\n\n\n\nChat\nA chat object that can be used to interact with a language model.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#image-input",
    "href": "reference/index.html#image-input",
    "title": "Function reference",
    "section": "",
    "text": "Submit image input to the chat\n\n\n\ncontent_image_file\nEncode image content from a file for chat input.\n\n\ncontent_image_plot\nEncode the current matplotlib plot as an image for chat input.\n\n\ncontent_image_url\nEncode image content from a URL for chat input.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#pdf-input",
    "href": "reference/index.html#pdf-input",
    "title": "Function reference",
    "section": "",
    "text": "Submit pdf input to the chat\n\n\n\ncontent_pdf_file\nPrepare a local PDF for input to a chat.\n\n\ncontent_pdf_url\nUse a remote PDF for input to a chat.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#prompt-interpolation",
    "href": "reference/index.html#prompt-interpolation",
    "title": "Function reference",
    "section": "",
    "text": "Interpolate variables into prompt templates\n\n\n\ninterpolate\nInterpolate variables into a prompt\n\n\ninterpolate_file\nInterpolate variables into a prompt from a file",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#tool-calling",
    "href": "reference/index.html#tool-calling",
    "title": "Function reference",
    "section": "",
    "text": "Add context to python function before registering it as a tool.\n\n\n\nTool\nDefine a tool\n\n\nToolRejectError\nError to represent a tool call being rejected.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#turns",
    "href": "reference/index.html#turns",
    "title": "Function reference",
    "section": "",
    "text": "A provider-agnostic representation of content generated during an assistant/user turn.\n\n\n\nTurn\nA user or assistant turn",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#query-token-usage",
    "href": "reference/index.html#query-token-usage",
    "title": "Function reference",
    "section": "",
    "text": "token_usage\nReport on token usage in the current session",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#implement-a-model-provider",
    "href": "reference/index.html#implement-a-model-provider",
    "title": "Function reference",
    "section": "",
    "text": "Provider\nA model provider interface for a Chat.",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#user-facing-types",
    "href": "reference/index.html#user-facing-types",
    "title": "Function reference",
    "section": "",
    "text": "types.Content\nBase class for all content types that can be appear in a Turn\n\n\ntypes.ContentImage\nBase class for image content.\n\n\ntypes.ContentImageInline\nInline image content.\n\n\ntypes.ContentImageRemote\nImage content from a URL.\n\n\ntypes.ContentJson\nJSON content\n\n\ntypes.ContentText\nText content for a Turn\n\n\ntypes.ContentToolRequest\nA request to call a tool/function\n\n\ntypes.ContentToolResult\nThe result of calling a tool/function\n\n\ntypes.ChatResponse\nChat response object.\n\n\ntypes.ChatResponseAsync\nChat response (async) object.\n\n\ntypes.ImageContentTypes\nAllowable content types for images.\n\n\ntypes.MISSING_TYPE\nA singleton representing a missing value.\n\n\ntypes.MISSING\n\n\n\ntypes.SubmitInputArgsT\nA TypedDict representing the arguments that can be passed to the .chat()\n\n\ntypes.TokenUsage\nToken usage for a given provider (name).",
    "crumbs": [
      "Reference",
      "Function reference"
    ]
  },
  {
    "objectID": "reference/types.ContentImage.html",
    "href": "reference/types.ContentImage.html",
    "title": "types.ContentImage",
    "section": "",
    "text": "types.ContentImage\ntypes.ContentImage()\nBase class for image content.\nThis class is not meant to be used directly. Instead, use content_image_url, content_image_file, or content_image_plot.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentImage"
    ]
  },
  {
    "objectID": "reference/types.ContentToolRequest.html",
    "href": "reference/types.ContentToolRequest.html",
    "title": "types.ContentToolRequest",
    "section": "",
    "text": "types.ContentToolRequest()\nA request to call a tool/function\nThis content type isn‚Äôt meant to be used directly. Instead, it‚Äôs automatically generated by Chat when a tool/function is requested by the model assistant.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid\n\nA unique identifier for this request.\nrequired\n\n\nname\n\nThe name of the tool/function to call.\nrequired\n\n\narguments\n\nThe arguments to pass to the tool/function.\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ntagify\nReturns an HTML string suitable for passing to htmltools/shiny‚Äôs Chat() component.\n\n\n\n\n\ntypes.ContentToolRequest.tagify()\nReturns an HTML string suitable for passing to htmltools/shiny‚Äôs Chat() component.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolRequest"
    ]
  },
  {
    "objectID": "reference/types.ContentToolRequest.html#parameters",
    "href": "reference/types.ContentToolRequest.html#parameters",
    "title": "types.ContentToolRequest",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nid\n\nA unique identifier for this request.\nrequired\n\n\nname\n\nThe name of the tool/function to call.\nrequired\n\n\narguments\n\nThe arguments to pass to the tool/function.\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolRequest"
    ]
  },
  {
    "objectID": "reference/types.ContentToolRequest.html#methods",
    "href": "reference/types.ContentToolRequest.html#methods",
    "title": "types.ContentToolRequest",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ntagify\nReturns an HTML string suitable for passing to htmltools/shiny‚Äôs Chat() component.\n\n\n\n\n\ntypes.ContentToolRequest.tagify()\nReturns an HTML string suitable for passing to htmltools/shiny‚Äôs Chat() component.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolRequest"
    ]
  },
  {
    "objectID": "reference/types.SubmitInputArgsT.html",
    "href": "reference/types.SubmitInputArgsT.html",
    "title": "types.SubmitInputArgsT",
    "section": "",
    "text": "types.SubmitInputArgsT\ntypes.SubmitInputArgsT\nA TypedDict representing the arguments that can be passed to the .chat() method of a Chat instance.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.SubmitInputArgsT"
    ]
  },
  {
    "objectID": "reference/image_file.html",
    "href": "reference/image_file.html",
    "title": "content_image_file",
    "section": "",
    "text": "content_image_file(path, content_type='auto', resize='low')\nEncode image content from a file for chat input.\nThis function is used to prepare image files for input to the chatbot. It can handle various image formats and provides options for resizing.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nThe path to the image file to include in the chat input.\nrequired\n\n\ncontent_type\nLiteral['auto', ImageContentTypes]\nThe content type of the image (e.g., \"image/png\"). If \"auto\", the content type is inferred from the file extension.\n'auto'\n\n\nresize\nUnion[str, Literal['none', 'low', 'high']]\nResizing option for the image. Can be: - \"none\": No resizing - \"low\": Resize to fit within 512x512 - \"high\": Resize to fit within 2000x768 or 768x2000 - Custom string (e.g., \"200x200\", \"300x200&gt;!\", etc.)\n'low'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.\n\n\n\n\n\n\nfrom chatlas import ChatOpenAI, content_image_file\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_file(\"path/to/image.png\"),\n)\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf the specified file does not exist.\n\n\n\nValueError\nIf the file extension is unsupported or the resize option is invalid."
  },
  {
    "objectID": "reference/image_file.html#parameters",
    "href": "reference/image_file.html#parameters",
    "title": "content_image_file",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nThe path to the image file to include in the chat input.\nrequired\n\n\ncontent_type\nLiteral['auto', ImageContentTypes]\nThe content type of the image (e.g., \"image/png\"). If \"auto\", the content type is inferred from the file extension.\n'auto'\n\n\nresize\nUnion[str, Literal['none', 'low', 'high']]\nResizing option for the image. Can be: - \"none\": No resizing - \"low\": Resize to fit within 512x512 - \"high\": Resize to fit within 2000x768 or 768x2000 - Custom string (e.g., \"200x200\", \"300x200&gt;!\", etc.)\n'low'"
  },
  {
    "objectID": "reference/image_file.html#returns",
    "href": "reference/image_file.html#returns",
    "title": "content_image_file",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object."
  },
  {
    "objectID": "reference/image_file.html#examples",
    "href": "reference/image_file.html#examples",
    "title": "content_image_file",
    "section": "",
    "text": "from chatlas import ChatOpenAI, content_image_file\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_file(\"path/to/image.png\"),\n)"
  },
  {
    "objectID": "reference/image_file.html#raises",
    "href": "reference/image_file.html#raises",
    "title": "content_image_file",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf the specified file does not exist.\n\n\n\nValueError\nIf the file extension is unsupported or the resize option is invalid."
  },
  {
    "objectID": "reference/ToolRejectError.html",
    "href": "reference/ToolRejectError.html",
    "title": "ToolRejectError",
    "section": "",
    "text": "ToolRejectError(reason='The user has chosen to disallow the tool call.')\nError to represent a tool call being rejected.\nThis error is meant to be raised when an end user has chosen to deny a tool call. It can be raised in a tool function or in a .on_tool_request() callback registered via a :class:~chatlas.Chat. When used in the callback, the tool call is rejected before the tool function is invoked.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nreason\nstr\nA string describing the reason for rejecting the tool call. This will be included in the error message passed to the LLM. In addition to the reason, the error message will also include ‚ÄúTool call rejected.‚Äù to indicate that the tool call was not processed.\n'The user has chosen to disallow the tool call.'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nToolRejectError\nAn error with a message informing the LLM that the tool call was rejected (and the reason why).\n\n\n\n\n\n\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; import chatlas as ctl\n&gt;&gt;&gt;\n&gt;&gt;&gt; chat = ctl.ChatOpenAI()\n&gt;&gt;&gt;\n&gt;&gt;&gt; def list_files():\n...     \"List files in the user's current directory\"\n...     while True:\n...         allow = input(\n...             \"Would you like to allow access to your current directory? (yes/no): \"\n...         )\n...         if allow.lower() == \"yes\":\n...             return os.listdir(\".\")\n...         elif allow.lower() == \"no\":\n...             raise ctl.ToolRejectError(\n...                 \"The user has chosen to disallow the tool call.\"\n...             )\n...         else:\n...             print(\"Please answer with 'yes' or 'no'.\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; chat.register_tool(list_files)\n&gt;&gt;&gt; chat.chat(\"What files are available in my current directory?\")",
    "crumbs": [
      "Reference",
      "Tool calling",
      "ToolRejectError"
    ]
  },
  {
    "objectID": "reference/ToolRejectError.html#parameters",
    "href": "reference/ToolRejectError.html#parameters",
    "title": "ToolRejectError",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nreason\nstr\nA string describing the reason for rejecting the tool call. This will be included in the error message passed to the LLM. In addition to the reason, the error message will also include ‚ÄúTool call rejected.‚Äù to indicate that the tool call was not processed.\n'The user has chosen to disallow the tool call.'",
    "crumbs": [
      "Reference",
      "Tool calling",
      "ToolRejectError"
    ]
  },
  {
    "objectID": "reference/ToolRejectError.html#raises",
    "href": "reference/ToolRejectError.html#raises",
    "title": "ToolRejectError",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nToolRejectError\nAn error with a message informing the LLM that the tool call was rejected (and the reason why).",
    "crumbs": [
      "Reference",
      "Tool calling",
      "ToolRejectError"
    ]
  },
  {
    "objectID": "reference/ToolRejectError.html#examples",
    "href": "reference/ToolRejectError.html#examples",
    "title": "ToolRejectError",
    "section": "",
    "text": "&gt;&gt;&gt; import os\n&gt;&gt;&gt; import chatlas as ctl\n&gt;&gt;&gt;\n&gt;&gt;&gt; chat = ctl.ChatOpenAI()\n&gt;&gt;&gt;\n&gt;&gt;&gt; def list_files():\n...     \"List files in the user's current directory\"\n...     while True:\n...         allow = input(\n...             \"Would you like to allow access to your current directory? (yes/no): \"\n...         )\n...         if allow.lower() == \"yes\":\n...             return os.listdir(\".\")\n...         elif allow.lower() == \"no\":\n...             raise ctl.ToolRejectError(\n...                 \"The user has chosen to disallow the tool call.\"\n...             )\n...         else:\n...             print(\"Please answer with 'yes' or 'no'.\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; chat.register_tool(list_files)\n&gt;&gt;&gt; chat.chat(\"What files are available in my current directory?\")",
    "crumbs": [
      "Reference",
      "Tool calling",
      "ToolRejectError"
    ]
  },
  {
    "objectID": "reference/content_pdf_file.html",
    "href": "reference/content_pdf_file.html",
    "title": "content_pdf_file",
    "section": "",
    "text": "content_pdf_file(path)\nPrepare a local PDF for input to a chat.\nNot all providers support PDF input, so check the documentation for the provider you are using.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nUnion[str, os.PathLike]\nA path to a local PDF file.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "PDF input",
      "content_pdf_file"
    ]
  },
  {
    "objectID": "reference/content_pdf_file.html#parameters",
    "href": "reference/content_pdf_file.html#parameters",
    "title": "content_pdf_file",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npath\nUnion[str, os.PathLike]\nA path to a local PDF file.\nrequired",
    "crumbs": [
      "Reference",
      "PDF input",
      "content_pdf_file"
    ]
  },
  {
    "objectID": "reference/content_pdf_file.html#returns",
    "href": "reference/content_pdf_file.html#returns",
    "title": "content_pdf_file",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "PDF input",
      "content_pdf_file"
    ]
  },
  {
    "objectID": "reference/ChatGoogle.html",
    "href": "reference/ChatGoogle.html",
    "title": "ChatGoogle",
    "section": "",
    "text": "ChatGoogle(\n    system_prompt=None,\n    turns=None,\n    model=None,\n    api_key=None,\n    kwargs=None,\n)\nChat with a Google Gemini model.\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nTo use Google‚Äôs models (i.e., Gemini), you‚Äôll need to sign up for an account and get an API key.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatGoogle requires the google-genai package: pip install \"chatlas[google]\".\n\n\n\n\n\nimport os\nfrom chatlas import ChatGoogle\n\nchat = ChatGoogle(api_key=os.getenv(\"GOOGLE_API_KEY\"))\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the GOOGLE_API_KEY environment variable.\nNone\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the genai.Client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.\n\n\n\n\n\n\nPasting an API key into a chat constructor (e.g., ChatGoogle(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nGOOGLE_API_KEY=...\nfrom chatlas import ChatGoogle\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatGoogle()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport GOOGLE_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGoogle"
    ]
  },
  {
    "objectID": "reference/ChatGoogle.html#prerequisites",
    "href": "reference/ChatGoogle.html#prerequisites",
    "title": "ChatGoogle",
    "section": "",
    "text": "API key\n\n\n\nTo use Google‚Äôs models (i.e., Gemini), you‚Äôll need to sign up for an account and get an API key.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatGoogle requires the google-genai package: pip install \"chatlas[google]\".",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGoogle"
    ]
  },
  {
    "objectID": "reference/ChatGoogle.html#examples",
    "href": "reference/ChatGoogle.html#examples",
    "title": "ChatGoogle",
    "section": "",
    "text": "import os\nfrom chatlas import ChatGoogle\n\nchat = ChatGoogle(api_key=os.getenv(\"GOOGLE_API_KEY\"))\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGoogle"
    ]
  },
  {
    "objectID": "reference/ChatGoogle.html#parameters",
    "href": "reference/ChatGoogle.html#parameters",
    "title": "ChatGoogle",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the GOOGLE_API_KEY environment variable.\nNone\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the genai.Client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGoogle"
    ]
  },
  {
    "objectID": "reference/ChatGoogle.html#returns",
    "href": "reference/ChatGoogle.html#returns",
    "title": "ChatGoogle",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGoogle"
    ]
  },
  {
    "objectID": "reference/ChatGoogle.html#note",
    "href": "reference/ChatGoogle.html#note",
    "title": "ChatGoogle",
    "section": "",
    "text": "Pasting an API key into a chat constructor (e.g., ChatGoogle(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nGOOGLE_API_KEY=...\nfrom chatlas import ChatGoogle\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatGoogle()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport GOOGLE_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGoogle"
    ]
  },
  {
    "objectID": "reference/image_plot.html",
    "href": "reference/image_plot.html",
    "title": "content_image_plot",
    "section": "",
    "text": "content_image_plot(width=768, height=768, dpi=72)\nEncode the current matplotlib plot as an image for chat input.\nThis function captures the current matplotlib plot, resizes it to the specified dimensions, and prepares it for chat input.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nThe desired width of the output image in pixels.\n768\n\n\nheight\nint\nThe desired height of the output image in pixels.\n768\n\n\ndpi\nint\nThe DPI (dots per inch) of the output image.\n72\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf width or height is not a positive integer.\n\n\n\n\n\n\nfrom chatlas import ChatOpenAI, content_image_plot\nimport matplotlib.pyplot as plt\n\nplt.scatter(faithful[\"eruptions\"], faithful[\"waiting\"])\nchat = ChatOpenAI()\nchat.chat(\n    \"Describe this plot in one paragraph, as suitable for inclusion in \"\n    \"alt-text. You should briefly describe the plot type, the axes, and \"\n    \"2-5 major visual patterns.\",\n    content_image_plot(),\n)"
  },
  {
    "objectID": "reference/image_plot.html#parameters",
    "href": "reference/image_plot.html#parameters",
    "title": "content_image_plot",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nThe desired width of the output image in pixels.\n768\n\n\nheight\nint\nThe desired height of the output image in pixels.\n768\n\n\ndpi\nint\nThe DPI (dots per inch) of the output image.\n72"
  },
  {
    "objectID": "reference/image_plot.html#returns",
    "href": "reference/image_plot.html#returns",
    "title": "content_image_plot",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object."
  },
  {
    "objectID": "reference/image_plot.html#raises",
    "href": "reference/image_plot.html#raises",
    "title": "content_image_plot",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf width or height is not a positive integer."
  },
  {
    "objectID": "reference/image_plot.html#examples",
    "href": "reference/image_plot.html#examples",
    "title": "content_image_plot",
    "section": "",
    "text": "from chatlas import ChatOpenAI, content_image_plot\nimport matplotlib.pyplot as plt\n\nplt.scatter(faithful[\"eruptions\"], faithful[\"waiting\"])\nchat = ChatOpenAI()\nchat.chat(\n    \"Describe this plot in one paragraph, as suitable for inclusion in \"\n    \"alt-text. You should briefly describe the plot type, the axes, and \"\n    \"2-5 major visual patterns.\",\n    content_image_plot(),\n)"
  },
  {
    "objectID": "reference/ChatOllama.html",
    "href": "reference/ChatOllama.html",
    "title": "ChatOllama",
    "section": "",
    "text": "ChatOllama(\n    model=None,\n    *,\n    system_prompt=None,\n    turns=None,\n    base_url='http://localhost:11434',\n    seed=None,\n    kwargs=None,\n)\nChat with a local Ollama model.\nOllama makes it easy to run a wide-variety of open-source models locally, making it a great choice for privacy and security.\n\n\n\n\n\n\n\n\nOllama runtime\n\n\n\nChatOllama requires the ollama executable to be installed and running on your machine.\n\n\n\n\n\n\n\n\nPull model(s)\n\n\n\nOnce ollama is running locally, download a model from the command line (e.g.¬†ollama pull llama3.2).\n\n\n\n\n\nfrom chatlas import ChatOllama\n\nchat = ChatOllama(model=\"llama3.2\")\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nOptional[str]\nThe model to use for the chat. If None, a list of locally installed models will be printed.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses ollama‚Äôs API.\n'http://localhost:11434'\n\n\nseed\nOptional[int]\nOptional integer seed that helps to make output more reproducible.\nNone\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone\n\n\n\n\n\n\nThis function is a lightweight wrapper around ChatOpenAI with the defaults tweaked for ollama.\n\n\n\nChatOllama currently doesn‚Äôt work with streaming tools, and tool calling more generally doesn‚Äôt seem to work very well with currently available models.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOllama"
    ]
  },
  {
    "objectID": "reference/ChatOllama.html#prerequisites",
    "href": "reference/ChatOllama.html#prerequisites",
    "title": "ChatOllama",
    "section": "",
    "text": "Ollama runtime\n\n\n\nChatOllama requires the ollama executable to be installed and running on your machine.\n\n\n\n\n\n\n\n\nPull model(s)\n\n\n\nOnce ollama is running locally, download a model from the command line (e.g.¬†ollama pull llama3.2).",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOllama"
    ]
  },
  {
    "objectID": "reference/ChatOllama.html#examples",
    "href": "reference/ChatOllama.html#examples",
    "title": "ChatOllama",
    "section": "",
    "text": "from chatlas import ChatOllama\n\nchat = ChatOllama(model=\"llama3.2\")\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOllama"
    ]
  },
  {
    "objectID": "reference/ChatOllama.html#parameters",
    "href": "reference/ChatOllama.html#parameters",
    "title": "ChatOllama",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nmodel\nOptional[str]\nThe model to use for the chat. If None, a list of locally installed models will be printed.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses ollama‚Äôs API.\n'http://localhost:11434'\n\n\nseed\nOptional[int]\nOptional integer seed that helps to make output more reproducible.\nNone\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOllama"
    ]
  },
  {
    "objectID": "reference/ChatOllama.html#note",
    "href": "reference/ChatOllama.html#note",
    "title": "ChatOllama",
    "section": "",
    "text": "This function is a lightweight wrapper around ChatOpenAI with the defaults tweaked for ollama.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOllama"
    ]
  },
  {
    "objectID": "reference/ChatOllama.html#limitations",
    "href": "reference/ChatOllama.html#limitations",
    "title": "ChatOllama",
    "section": "",
    "text": "ChatOllama currently doesn‚Äôt work with streaming tools, and tool calling more generally doesn‚Äôt seem to work very well with currently available models.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOllama"
    ]
  },
  {
    "objectID": "reference/ChatAuto.html",
    "href": "reference/ChatAuto.html",
    "title": "ChatAuto",
    "section": "",
    "text": "ChatAuto(system_prompt=None, turns=None, *, provider=None, model=None, **kwargs)\nUse environment variables (env vars) to configure the Chat provider and model.\nCreates a :class:~chatlas.Chat instance based on the specified provider. The provider may be specified through the provider parameter and/or the CHATLAS_CHAT_PROVIDER env var. If both are set, the env var takes precedence. Similarly, the provider‚Äôs model may be specified through the model parameter and/or the CHATLAS_CHAT_MODEL env var. Also, additional configuration may be provided through the kwargs parameter and/or the CHATLAS_CHAT_ARGS env var (as a JSON string). In this case, when both are set, they are merged, with the env var arguments taking precedence.\nAs a result, ChatAuto() provides a convenient way to set a default provider and model in your Python code, while allowing you to override these settings through env vars (i.e., without modifying your code).\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nFollow the instructions for the specific provider to obtain an API key.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nFollow the instructions for the specific provider to install the required Python packages.\n\n\n\n\n\nFirst, set the environment variables for the provider, arguments, and API key:\nexport CHATLAS_CHAT_PROVIDER=anthropic\nexport CHATLAS_CHAT_MODEL=claude-3-haiku-20240229\nexport CHATLAS_CHAT_ARGS='{\"kwargs\": {\"max_retries\": 3}}'\nexport ANTHROPIC_API_KEY=your_api_key\nThen, you can use the ChatAuto function to create a Chat instance:\nfrom chatlas import ChatAuto\n\nchat = ChatAuto()\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprovider\nOptional[AutoProviders]\nThe name of the default chat provider to use. Providers are strings formatted in kebab-case, e.g.¬†to use ChatBedrockAnthropic set provider=\"bedrock-anthropic\". This value can also be provided via the CHATLAS_CHAT_PROVIDER environment variable, which takes precedence over provider when set.\nNone\n\n\nmodel\nOptional[str]\nThe name of the default model to use. This value can also be provided via the CHATLAS_CHAT_MODEL environment variable, which takes precedence over model when set.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\n**kwargs\n\nAdditional keyword arguments to pass to the Chat constructor. See the documentation for each provider for more details on the available options. These arguments can also be provided via the CHATLAS_CHAT_ARGS environment variable as a JSON string. When provided, the options in the CHATLAS_CHAT_ARGS envvar take precedence over the options passed to kwargs. Note that system_prompt and turns in kwargs or in CHATLAS_CHAT_ARGS are ignored.\n{}\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA chat instance using the specified provider.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf no valid provider is specified either through parameters or environment variables.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAuto"
    ]
  },
  {
    "objectID": "reference/ChatAuto.html#prerequisites",
    "href": "reference/ChatAuto.html#prerequisites",
    "title": "ChatAuto",
    "section": "",
    "text": "API key\n\n\n\nFollow the instructions for the specific provider to obtain an API key.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nFollow the instructions for the specific provider to install the required Python packages.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAuto"
    ]
  },
  {
    "objectID": "reference/ChatAuto.html#examples",
    "href": "reference/ChatAuto.html#examples",
    "title": "ChatAuto",
    "section": "",
    "text": "First, set the environment variables for the provider, arguments, and API key:\nexport CHATLAS_CHAT_PROVIDER=anthropic\nexport CHATLAS_CHAT_MODEL=claude-3-haiku-20240229\nexport CHATLAS_CHAT_ARGS='{\"kwargs\": {\"max_retries\": 3}}'\nexport ANTHROPIC_API_KEY=your_api_key\nThen, you can use the ChatAuto function to create a Chat instance:\nfrom chatlas import ChatAuto\n\nchat = ChatAuto()\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAuto"
    ]
  },
  {
    "objectID": "reference/ChatAuto.html#parameters",
    "href": "reference/ChatAuto.html#parameters",
    "title": "ChatAuto",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nprovider\nOptional[AutoProviders]\nThe name of the default chat provider to use. Providers are strings formatted in kebab-case, e.g.¬†to use ChatBedrockAnthropic set provider=\"bedrock-anthropic\". This value can also be provided via the CHATLAS_CHAT_PROVIDER environment variable, which takes precedence over provider when set.\nNone\n\n\nmodel\nOptional[str]\nThe name of the default model to use. This value can also be provided via the CHATLAS_CHAT_MODEL environment variable, which takes precedence over model when set.\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\n**kwargs\n\nAdditional keyword arguments to pass to the Chat constructor. See the documentation for each provider for more details on the available options. These arguments can also be provided via the CHATLAS_CHAT_ARGS environment variable as a JSON string. When provided, the options in the CHATLAS_CHAT_ARGS envvar take precedence over the options passed to kwargs. Note that system_prompt and turns in kwargs or in CHATLAS_CHAT_ARGS are ignored.\n{}",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAuto"
    ]
  },
  {
    "objectID": "reference/ChatAuto.html#returns",
    "href": "reference/ChatAuto.html#returns",
    "title": "ChatAuto",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA chat instance using the specified provider.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAuto"
    ]
  },
  {
    "objectID": "reference/ChatAuto.html#raises",
    "href": "reference/ChatAuto.html#raises",
    "title": "ChatAuto",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf no valid provider is specified either through parameters or environment variables.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatAuto"
    ]
  },
  {
    "objectID": "reference/types.ContentText.html",
    "href": "reference/types.ContentText.html",
    "title": "types.ContentText",
    "section": "",
    "text": "types.ContentText\ntypes.ContentText(**data)\nText content for a Turn",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentText"
    ]
  },
  {
    "objectID": "reference/Chat.html",
    "href": "reference/Chat.html",
    "title": "Chat",
    "section": "",
    "text": "Chat(provider, turns=None)\nA chat object that can be used to interact with a language model.\nA Chat is an sequence of sequence of user and assistant Turns sent to a specific Provider. A Chat takes care of managing the state associated with the chat; i.e.¬†it records the messages that you send to the server, and the messages that you receive back. If you register a tool (i.e.¬†an function that the assistant can call on your behalf), it also takes care of the tool loop.\nYou should generally not create this object yourself, but instead call ChatOpenAI or friends instead.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncurrent_display\nGet the currently active markdown display, if any.\n\n\nsystem_prompt\nA property to get (or set) the system prompt for the chat.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napp\nEnter a web-based chat app to interact with the LLM.\n\n\nchat\nGenerate a response from the chat.\n\n\nchat_async\nGenerate a response from the chat asynchronously.\n\n\nconsole\nEnter a chat console to interact with the LLM.\n\n\nexport\nExport the chat history to a file.\n\n\nextract_data\nExtract structured data from the given input.\n\n\nextract_data_async\nExtract structured data from the given input asynchronously.\n\n\nget_last_turn\nGet the last turn in the chat with a specific role.\n\n\nget_turns\nGet all the turns (i.e., message contents) in the chat.\n\n\non_tool_request\nRegister a callback for a tool request event.\n\n\non_tool_result\nRegister a callback for a tool result event.\n\n\nregister_tool\nRegister a tool (function) with the chat.\n\n\nset_echo_options\nSet echo styling options for the chat.\n\n\nset_turns\nSet the turns of the chat.\n\n\nstream\nGenerate a response from the chat in a streaming fashion.\n\n\nstream_async\nGenerate a response from the chat in a streaming fashion asynchronously.\n\n\ntoken_count\nGet an estimated token count for the given input.\n\n\ntoken_count_async\nGet an estimated token count for the given input asynchronously.\n\n\ntokens\nGet the tokens for each turn in the chat.\n\n\n\n\n\nChat.app(\n    stream=True,\n    port=0,\n    launch_browser=True,\n    bg_thread=None,\n    echo=None,\n    content='all',\n    kwargs=None,\n)\nEnter a web-based chat app to interact with the LLM.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nport\nint\nThe port to run the app on (the default is 0, which will choose a random port).\n0\n\n\nlaunch_browser\nbool\nWhether to launch a browser window.\nTrue\n\n\nbg_thread\nOptional[bool]\nWhether to run the app in a background thread. If None, the app will run in a background thread if the current environment is a notebook.\nNone\n\n\necho\nOptional[EchoOptions]\nWhether to echo text content, all content (i.e., tool calls), or no content. Defaults to \"none\" when stream=True and \"text\" when stream=False.\nNone\n\n\ncontent\nLiteral['text', 'all']\nWhether to display text content or all content (i.e., tool calls).\n'all'\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\nChat.chat(*args, echo='output', stream=True, kwargs=None)\nGenerate a response from the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'output'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponse\nA (consumed) response from the chat. Apply str() to this object to get the text content of the response.\n\n\n\n\n\n\n\nChat.chat_async(*args, echo='output', stream=True, kwargs=None)\nGenerate a response from the chat asynchronously.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls, images, etc), or no content.\n'output'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponseAsync\nA (consumed) response from the chat. Apply str() to this object to get the text content of the response.\n\n\n\n\n\n\n\nChat.console(echo='output', stream=True, kwargs=None)\nEnter a chat console to interact with the LLM.\nTo quit, input ‚Äòexit‚Äô or press Ctrl+C.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'output'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nChat.export(\n    filename,\n    *,\n    turns=None,\n    title=None,\n    content='text',\n    include_system_prompt=True,\n    overwrite=False,\n)\nExport the chat history to a file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr | Path\nThe filename to export the chat to. Currently this must be a .md or .html file.\nrequired\n\n\nturns\nOptional[Sequence[Turn]]\nThe .get_turns() to export. If not provided, the chat‚Äôs current turns will be used.\nNone\n\n\ntitle\nOptional[str]\nA title to place at the top of the exported file.\nNone\n\n\noverwrite\nbool\nWhether to overwrite the file if it already exists.\nFalse\n\n\ncontent\nLiteral['text', 'all']\nWhether to include text content, all content (i.e., tool calls), or no content.\n'text'\n\n\ninclude_system_prompt\nbool\nWhether to include the system prompt in a \nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nPath\nThe path to the exported file.\n\n\n\n\n\n\n\nChat.extract_data(*args, data_model, echo='none', stream=False)\nExtract structured data from the given input.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to extract data from.\n()\n\n\ndata_model\ntype[BaseModel]\nA Pydantic model describing the structure of the data to extract.\nrequired\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'none'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nThe extracted data.\n\n\n\n\n\n\n\nChat.extract_data_async(*args, data_model, echo='none', stream=False)\nExtract structured data from the given input asynchronously.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to extract data from.\n()\n\n\ndata_model\ntype[BaseModel]\nA Pydantic model describing the structure of the data to extract.\nrequired\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content\n'none'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks). Defaults to True if echo is not ‚Äúnone‚Äù.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nThe extracted data.\n\n\n\n\n\n\n\nChat.get_last_turn(role='assistant')\nGet the last turn in the chat with a specific role.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrole\nLiteral['assistant', 'user', 'system']\nThe role of the turn to return.\n'assistant'\n\n\n\n\n\n\n\nChat.get_turns(include_system_prompt=False)\nGet all the turns (i.e., message contents) in the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninclude_system_prompt\nbool\nWhether to include the system prompt in the turns.\nFalse\n\n\n\n\n\n\n\nChat.on_tool_request(callback)\nRegister a callback for a tool request event.\nA tool request event occurs when the assistant requests a tool to be called on its behalf. Before invoking the tool, on_tool_request handlers are called with the relevant ContentToolRequest object. This is useful if you want to handle tool requests in a custom way, such as requiring logging them or requiring user approval before invoking the tool\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncallback\nCallable[[ContentToolRequest], None]\nA function to be called when a tool request event occurs. This function must have a single argument, which will be the tool request (i.e., a ContentToolRequest object).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nA callable that can be used to remove the callback later.\n\n\n\n\n\n\n\n\nChat.on_tool_result(callback)\nRegister a callback for a tool result event.\nA tool result event occurs when a tool has been invoked and the result is ready to be provided to the assistant. After the tool has been invoked, on_tool_result handlers are called with the relevant ContentToolResult object. This is useful if you want to handle tool results in a custom way such as logging them.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncallback\nCallable[[ContentToolResult], None]\nA function to be called when a tool result event occurs. This function must have a single argument, which will be the tool result (i.e., a ContentToolResult object).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nA callable that can be used to remove the callback later.\n\n\n\n\n\n\n\n\nChat.register_tool(func, *, model=None)\nRegister a tool (function) with the chat.\nThe function will always be invoked in the current Python process.\n\n\nIf your tool has straightforward input parameters, you can just register the function directly (type hints and a docstring explaning both what the function does and what the parameters are for is strongly recommended):\nfrom chatlas import ChatOpenAI, Tool\n\n\ndef add(a: int, b: int) -&gt; int:\n    '''\n    Add two numbers together.\n\n####     Parameters {.doc-section .doc-section-----parameters}\n\n    a : int\n        The first number to add.\n    b : int\n        The second number to add.\n    '''\n    return a + b\n\n\nchat = ChatOpenAI()\nchat.register_tool(add)\nchat.chat(\"What is 2 + 2?\")\nIf your tool has more complex input parameters, you can provide a Pydantic model that corresponds to the input parameters for the function, This way, you can have fields that hold other model(s) (for more complex input parameters), and also more directly document the input parameters:\nfrom chatlas import ChatOpenAI, Tool\nfrom pydantic import BaseModel, Field\n\n\nclass AddParams(BaseModel):\n    '''Add two numbers together.'''\n\n    a: int = Field(description=\"The first number to add.\")\n\n    b: int = Field(description=\"The second number to add.\")\n\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\nchat = ChatOpenAI()\nchat.register_tool(add, model=AddParams)\nchat.chat(\"What is 2 + 2?\")\n\n\n\n\n\nfunc The function to be invoked when the tool is called. model A Pydantic model that describes the input parameters for the function. If not provided, the model will be inferred from the function‚Äôs type hints. The primary reason why you might want to provide a model in Note that the name and docstring of the model takes precedence over the name and docstring of the function.\n\n\nChat.set_echo_options(rich_markdown=None, rich_console=None, css_styles=None)\nSet echo styling options for the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrich_markdown\nOptional[dict[str, Any]]\nA dictionary of options to pass to rich.markdown.Markdown(). This is only relevant when outputting to the console.\nNone\n\n\nrich_console\nOptional[dict[str, Any]]\nA dictionary of options to pass to rich.console.Console(). This is only relevant when outputting to the console.\nNone\n\n\ncss_styles\nOptional[dict[str, str]]\nA dictionary of CSS styles to apply to IPython.display.Markdown(). This is only relevant when outputing to the browser.\nNone\n\n\n\n\n\n\n\nChat.set_turns(turns)\nSet the turns of the chat.\nThis method is primarily useful for clearing or setting the turns of the chat (i.e., limiting the context window).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nturns\nSequence[Turn]\nThe turns to set. Turns with the role ‚Äúsystem‚Äù are not allowed.\nrequired\n\n\n\n\n\n\n\nChat.stream(*args, echo='none', content='text', kwargs=None)\nGenerate a response from the chat in a streaming fashion.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'none'\n\n\ncontent\nLiteral['text', 'all']\nWhether to yield just text content, or all content (i.e., tool calls).\n'text'\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponse\nAn (unconsumed) response from the chat. Iterate over this object to consume the response.\n\n\n\n\n\n\n\nChat.stream_async(*args, echo='none', content='text', kwargs=None)\nGenerate a response from the chat in a streaming fashion asynchronously.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'none'\n\n\ncontent\nLiteral['text', 'all']\nWhether to yield just text content, or all content (i.e., tool calls).\n'text'\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponseAsync\nAn (unconsumed) response from the chat. Iterate over this object to consume the response.\n\n\n\n\n\n\n\nChat.token_count(*args, data_model=None)\nGet an estimated token count for the given input.\nEstimate the token size of input content. This can help determine whether input(s) and/or conversation history (i.e., .get_turns()) should be reduced in size before sending it to the model.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to get a token count for.\n()\n\n\ndata_model\nOptional[type[BaseModel]]\nIf the input is meant for data extraction (i.e., .extract_data()), then this should be the Pydantic model that describes the structure of the data to extract.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nThe token count for the input.\n\n\n\n\n\n\nRemember that the token count is an estimate. Also, models based on ChatOpenAI() currently does not take tools into account when estimating token counts.\n\n\n\nfrom chatlas import ChatAnthropic\n\nchat = ChatAnthropic()\n# Estimate the token count before sending the input\nprint(chat.token_count(\"What is 2 + 2?\"))\n\n# Once input is sent, you can get the actual input and output\n# token counts from the chat object\nchat.chat(\"What is 2 + 2?\", echo=\"none\")\nprint(chat.token_usage())\n\n\n\n\nChat.token_count_async(*args, data_model=None)\nGet an estimated token count for the given input asynchronously.\nEstimate the token size of input content. This can help determine whether input(s) and/or conversation history (i.e., .get_turns()) should be reduced in size before sending it to the model.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to get a token count for.\n()\n\n\ndata_model\nOptional[type[BaseModel]]\nIf this input is meant for data extraction (i.e., .extract_data_async()), then this should be the Pydantic model that describes the structure of the data to extract.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nThe token count for the input.\n\n\n\n\n\n\n\nChat.tokens(values='discrete')\nGet the tokens for each turn in the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\nLiteral['cumulative', 'discrete']\nIf ‚Äúcumulative‚Äù (the default), the result can be summed to get the chat‚Äôs overall token usage (helpful for computing overall cost of the chat). If ‚Äúdiscrete‚Äù, the result can be summed to get the number of tokens the turns will cost to generate the next response (helpful for estimating cost of the next response, or for determining if you are about to exceed the token limit).\n'discrete'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[int]\nA list of token counts for each (non-system) turn in the chat. The 1st turn includes the tokens count for the system prompt (if any).\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the chat‚Äôs turns (i.e., .get_turns()) are not in an expected format. This may happen if the chat history is manually set (i.e., .set_turns()). In this case, you can inspect the ‚Äúraw‚Äù token values via the .get_turns() method (each turn has a .tokens attribute).",
    "crumbs": [
      "Reference",
      "The chat object",
      "Chat"
    ]
  },
  {
    "objectID": "reference/Chat.html#attributes",
    "href": "reference/Chat.html#attributes",
    "title": "Chat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncurrent_display\nGet the currently active markdown display, if any.\n\n\nsystem_prompt\nA property to get (or set) the system prompt for the chat.",
    "crumbs": [
      "Reference",
      "The chat object",
      "Chat"
    ]
  },
  {
    "objectID": "reference/Chat.html#methods",
    "href": "reference/Chat.html#methods",
    "title": "Chat",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\napp\nEnter a web-based chat app to interact with the LLM.\n\n\nchat\nGenerate a response from the chat.\n\n\nchat_async\nGenerate a response from the chat asynchronously.\n\n\nconsole\nEnter a chat console to interact with the LLM.\n\n\nexport\nExport the chat history to a file.\n\n\nextract_data\nExtract structured data from the given input.\n\n\nextract_data_async\nExtract structured data from the given input asynchronously.\n\n\nget_last_turn\nGet the last turn in the chat with a specific role.\n\n\nget_turns\nGet all the turns (i.e., message contents) in the chat.\n\n\non_tool_request\nRegister a callback for a tool request event.\n\n\non_tool_result\nRegister a callback for a tool result event.\n\n\nregister_tool\nRegister a tool (function) with the chat.\n\n\nset_echo_options\nSet echo styling options for the chat.\n\n\nset_turns\nSet the turns of the chat.\n\n\nstream\nGenerate a response from the chat in a streaming fashion.\n\n\nstream_async\nGenerate a response from the chat in a streaming fashion asynchronously.\n\n\ntoken_count\nGet an estimated token count for the given input.\n\n\ntoken_count_async\nGet an estimated token count for the given input asynchronously.\n\n\ntokens\nGet the tokens for each turn in the chat.\n\n\n\n\n\nChat.app(\n    stream=True,\n    port=0,\n    launch_browser=True,\n    bg_thread=None,\n    echo=None,\n    content='all',\n    kwargs=None,\n)\nEnter a web-based chat app to interact with the LLM.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nport\nint\nThe port to run the app on (the default is 0, which will choose a random port).\n0\n\n\nlaunch_browser\nbool\nWhether to launch a browser window.\nTrue\n\n\nbg_thread\nOptional[bool]\nWhether to run the app in a background thread. If None, the app will run in a background thread if the current environment is a notebook.\nNone\n\n\necho\nOptional[EchoOptions]\nWhether to echo text content, all content (i.e., tool calls), or no content. Defaults to \"none\" when stream=True and \"text\" when stream=False.\nNone\n\n\ncontent\nLiteral['text', 'all']\nWhether to display text content or all content (i.e., tool calls).\n'all'\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\nChat.chat(*args, echo='output', stream=True, kwargs=None)\nGenerate a response from the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'output'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponse\nA (consumed) response from the chat. Apply str() to this object to get the text content of the response.\n\n\n\n\n\n\n\nChat.chat_async(*args, echo='output', stream=True, kwargs=None)\nGenerate a response from the chat asynchronously.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls, images, etc), or no content.\n'output'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponseAsync\nA (consumed) response from the chat. Apply str() to this object to get the text content of the response.\n\n\n\n\n\n\n\nChat.console(echo='output', stream=True, kwargs=None)\nEnter a chat console to interact with the LLM.\nTo quit, input ‚Äòexit‚Äô or press Ctrl+C.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'output'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nTrue\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nChat.export(\n    filename,\n    *,\n    turns=None,\n    title=None,\n    content='text',\n    include_system_prompt=True,\n    overwrite=False,\n)\nExport the chat history to a file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr | Path\nThe filename to export the chat to. Currently this must be a .md or .html file.\nrequired\n\n\nturns\nOptional[Sequence[Turn]]\nThe .get_turns() to export. If not provided, the chat‚Äôs current turns will be used.\nNone\n\n\ntitle\nOptional[str]\nA title to place at the top of the exported file.\nNone\n\n\noverwrite\nbool\nWhether to overwrite the file if it already exists.\nFalse\n\n\ncontent\nLiteral['text', 'all']\nWhether to include text content, all content (i.e., tool calls), or no content.\n'text'\n\n\ninclude_system_prompt\nbool\nWhether to include the system prompt in a \nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nPath\nThe path to the exported file.\n\n\n\n\n\n\n\nChat.extract_data(*args, data_model, echo='none', stream=False)\nExtract structured data from the given input.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to extract data from.\n()\n\n\ndata_model\ntype[BaseModel]\nA Pydantic model describing the structure of the data to extract.\nrequired\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'none'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks).\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nThe extracted data.\n\n\n\n\n\n\n\nChat.extract_data_async(*args, data_model, echo='none', stream=False)\nExtract structured data from the given input asynchronously.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to extract data from.\n()\n\n\ndata_model\ntype[BaseModel]\nA Pydantic model describing the structure of the data to extract.\nrequired\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content\n'none'\n\n\nstream\nbool\nWhether to stream the response (i.e., have the response appear in chunks). Defaults to True if echo is not ‚Äúnone‚Äù.\nFalse\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict[str, Any]\nThe extracted data.\n\n\n\n\n\n\n\nChat.get_last_turn(role='assistant')\nGet the last turn in the chat with a specific role.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrole\nLiteral['assistant', 'user', 'system']\nThe role of the turn to return.\n'assistant'\n\n\n\n\n\n\n\nChat.get_turns(include_system_prompt=False)\nGet all the turns (i.e., message contents) in the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninclude_system_prompt\nbool\nWhether to include the system prompt in the turns.\nFalse\n\n\n\n\n\n\n\nChat.on_tool_request(callback)\nRegister a callback for a tool request event.\nA tool request event occurs when the assistant requests a tool to be called on its behalf. Before invoking the tool, on_tool_request handlers are called with the relevant ContentToolRequest object. This is useful if you want to handle tool requests in a custom way, such as requiring logging them or requiring user approval before invoking the tool\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncallback\nCallable[[ContentToolRequest], None]\nA function to be called when a tool request event occurs. This function must have a single argument, which will be the tool request (i.e., a ContentToolRequest object).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nA callable that can be used to remove the callback later.\n\n\n\n\n\n\n\n\nChat.on_tool_result(callback)\nRegister a callback for a tool result event.\nA tool result event occurs when a tool has been invoked and the result is ready to be provided to the assistant. After the tool has been invoked, on_tool_result handlers are called with the relevant ContentToolResult object. This is useful if you want to handle tool results in a custom way such as logging them.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncallback\nCallable[[ContentToolResult], None]\nA function to be called when a tool result event occurs. This function must have a single argument, which will be the tool result (i.e., a ContentToolResult object).\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nA callable that can be used to remove the callback later.\n\n\n\n\n\n\n\n\nChat.register_tool(func, *, model=None)\nRegister a tool (function) with the chat.\nThe function will always be invoked in the current Python process.\n\n\nIf your tool has straightforward input parameters, you can just register the function directly (type hints and a docstring explaning both what the function does and what the parameters are for is strongly recommended):\nfrom chatlas import ChatOpenAI, Tool\n\n\ndef add(a: int, b: int) -&gt; int:\n    '''\n    Add two numbers together.\n\n####     Parameters {.doc-section .doc-section-----parameters}\n\n    a : int\n        The first number to add.\n    b : int\n        The second number to add.\n    '''\n    return a + b\n\n\nchat = ChatOpenAI()\nchat.register_tool(add)\nchat.chat(\"What is 2 + 2?\")\nIf your tool has more complex input parameters, you can provide a Pydantic model that corresponds to the input parameters for the function, This way, you can have fields that hold other model(s) (for more complex input parameters), and also more directly document the input parameters:\nfrom chatlas import ChatOpenAI, Tool\nfrom pydantic import BaseModel, Field\n\n\nclass AddParams(BaseModel):\n    '''Add two numbers together.'''\n\n    a: int = Field(description=\"The first number to add.\")\n\n    b: int = Field(description=\"The second number to add.\")\n\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n\nchat = ChatOpenAI()\nchat.register_tool(add, model=AddParams)\nchat.chat(\"What is 2 + 2?\")",
    "crumbs": [
      "Reference",
      "The chat object",
      "Chat"
    ]
  },
  {
    "objectID": "reference/Chat.html#parameters-11",
    "href": "reference/Chat.html#parameters-11",
    "title": "Chat",
    "section": "",
    "text": "func The function to be invoked when the tool is called. model A Pydantic model that describes the input parameters for the function. If not provided, the model will be inferred from the function‚Äôs type hints. The primary reason why you might want to provide a model in Note that the name and docstring of the model takes precedence over the name and docstring of the function.\n\n\nChat.set_echo_options(rich_markdown=None, rich_console=None, css_styles=None)\nSet echo styling options for the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrich_markdown\nOptional[dict[str, Any]]\nA dictionary of options to pass to rich.markdown.Markdown(). This is only relevant when outputting to the console.\nNone\n\n\nrich_console\nOptional[dict[str, Any]]\nA dictionary of options to pass to rich.console.Console(). This is only relevant when outputting to the console.\nNone\n\n\ncss_styles\nOptional[dict[str, str]]\nA dictionary of CSS styles to apply to IPython.display.Markdown(). This is only relevant when outputing to the browser.\nNone\n\n\n\n\n\n\n\nChat.set_turns(turns)\nSet the turns of the chat.\nThis method is primarily useful for clearing or setting the turns of the chat (i.e., limiting the context window).\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nturns\nSequence[Turn]\nThe turns to set. Turns with the role ‚Äúsystem‚Äù are not allowed.\nrequired\n\n\n\n\n\n\n\nChat.stream(*args, echo='none', content='text', kwargs=None)\nGenerate a response from the chat in a streaming fashion.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'none'\n\n\ncontent\nLiteral['text', 'all']\nWhether to yield just text content, or all content (i.e., tool calls).\n'text'\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponse\nAn (unconsumed) response from the chat. Iterate over this object to consume the response.\n\n\n\n\n\n\n\nChat.stream_async(*args, echo='none', content='text', kwargs=None)\nGenerate a response from the chat in a streaming fashion asynchronously.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe user input(s) to generate a response from.\n()\n\n\necho\nEchoOptions\nWhether to echo text content, all content (i.e., tool calls), or no content.\n'none'\n\n\ncontent\nLiteral['text', 'all']\nWhether to yield just text content, or all content (i.e., tool calls).\n'text'\n\n\nkwargs\nOptional[SubmitInputArgsT]\nAdditional keyword arguments to pass to the method used for requesting the response.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChatResponseAsync\nAn (unconsumed) response from the chat. Iterate over this object to consume the response.\n\n\n\n\n\n\n\nChat.token_count(*args, data_model=None)\nGet an estimated token count for the given input.\nEstimate the token size of input content. This can help determine whether input(s) and/or conversation history (i.e., .get_turns()) should be reduced in size before sending it to the model.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to get a token count for.\n()\n\n\ndata_model\nOptional[type[BaseModel]]\nIf the input is meant for data extraction (i.e., .extract_data()), then this should be the Pydantic model that describes the structure of the data to extract.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nThe token count for the input.\n\n\n\n\n\n\nRemember that the token count is an estimate. Also, models based on ChatOpenAI() currently does not take tools into account when estimating token counts.\n\n\n\nfrom chatlas import ChatAnthropic\n\nchat = ChatAnthropic()\n# Estimate the token count before sending the input\nprint(chat.token_count(\"What is 2 + 2?\"))\n\n# Once input is sent, you can get the actual input and output\n# token counts from the chat object\nchat.chat(\"What is 2 + 2?\", echo=\"none\")\nprint(chat.token_usage())\n\n\n\n\nChat.token_count_async(*args, data_model=None)\nGet an estimated token count for the given input asynchronously.\nEstimate the token size of input content. This can help determine whether input(s) and/or conversation history (i.e., .get_turns()) should be reduced in size before sending it to the model.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nContent | str\nThe input to get a token count for.\n()\n\n\ndata_model\nOptional[type[BaseModel]]\nIf this input is meant for data extraction (i.e., .extract_data_async()), then this should be the Pydantic model that describes the structure of the data to extract.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint\nThe token count for the input.\n\n\n\n\n\n\n\nChat.tokens(values='discrete')\nGet the tokens for each turn in the chat.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\nLiteral['cumulative', 'discrete']\nIf ‚Äúcumulative‚Äù (the default), the result can be summed to get the chat‚Äôs overall token usage (helpful for computing overall cost of the chat). If ‚Äúdiscrete‚Äù, the result can be summed to get the number of tokens the turns will cost to generate the next response (helpful for estimating cost of the next response, or for determining if you are about to exceed the token limit).\n'discrete'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[int]\nA list of token counts for each (non-system) turn in the chat. The 1st turn includes the tokens count for the system prompt (if any).\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf the chat‚Äôs turns (i.e., .get_turns()) are not in an expected format. This may happen if the chat history is manually set (i.e., .set_turns()). In this case, you can inspect the ‚Äúraw‚Äù token values via the .get_turns() method (each turn has a .tokens attribute).",
    "crumbs": [
      "Reference",
      "The chat object",
      "Chat"
    ]
  },
  {
    "objectID": "reference/interpolate_file.html",
    "href": "reference/interpolate_file.html",
    "title": "interpolate_file",
    "section": "",
    "text": "interpolate_file(\n    path,\n    *,\n    variables=None,\n    variable_start='{{',\n    variable_end='}}',\n)\nInterpolate variables into a prompt from a file\nThis is a light-weight wrapper around the Jinja2 templating engine, making it easier to interpolate dynamic data into a static prompt. Compared to f-strings, which expects you to wrap dynamic values in { }, this function expects { } instead, making it easier to include Python code and JSON in your prompt.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nUnion[str, Path]\nThe path to the file containing the prompt to interpolate.\nrequired\n\n\nvariables\nOptional[dict[str, Any]]\nA dictionary of variables to interpolate into the prompt. If not provided, the caller‚Äôs global and local variables are used.\nNone\n\n\nvariable_start\nstr\nThe string that marks the beginning of a variable.\n'{{'\n\n\nvariable_end\nstr\nThe string that marks the end of a variable.\n'}}'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nThe prompt with variables interpolated.\n\n\n\n\n\n\ninterpolate Interpolating data into a system prompt",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate_file"
    ]
  },
  {
    "objectID": "reference/interpolate_file.html#parameters",
    "href": "reference/interpolate_file.html#parameters",
    "title": "interpolate_file",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npath\nUnion[str, Path]\nThe path to the file containing the prompt to interpolate.\nrequired\n\n\nvariables\nOptional[dict[str, Any]]\nA dictionary of variables to interpolate into the prompt. If not provided, the caller‚Äôs global and local variables are used.\nNone\n\n\nvariable_start\nstr\nThe string that marks the beginning of a variable.\n'{{'\n\n\nvariable_end\nstr\nThe string that marks the end of a variable.\n'}}'",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate_file"
    ]
  },
  {
    "objectID": "reference/interpolate_file.html#returns",
    "href": "reference/interpolate_file.html#returns",
    "title": "interpolate_file",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nstr\nThe prompt with variables interpolated.",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate_file"
    ]
  },
  {
    "objectID": "reference/interpolate_file.html#see-also",
    "href": "reference/interpolate_file.html#see-also",
    "title": "interpolate_file",
    "section": "",
    "text": "interpolate Interpolating data into a system prompt",
    "crumbs": [
      "Reference",
      "Prompt interpolation",
      "interpolate_file"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html",
    "href": "reference/ChatGroq.html",
    "title": "ChatGroq",
    "section": "",
    "text": "ChatGroq(\n    system_prompt=None,\n    turns=None,\n    model=None,\n    api_key=None,\n    base_url='https://api.groq.com/openai/v1',\n    seed=MISSING,\n    kwargs=None,\n)\nChat with a model hosted on Groq.\nGroq provides a platform for highly efficient AI inference.\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nSign up at https://groq.com to get an API key.\n\n\n\n\n\nimport os\nfrom chatlas import ChatGroq\n\nchat = ChatGroq(api_key=os.getenv(\"GROQ_API_KEY\"))\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the GROQ_API_KEY environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses Groq‚Äôs API.\n'https://api.groq.com/openai/v1'\n\n\nseed\nOptional[int] | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.\n\n\n\n\n\n\nThis function is a lightweight wrapper around ChatOpenAI with the defaults tweaked for groq.\n\n\n\nPasting an API key into a chat constructor (e.g., ChatGroq(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nGROQ_API_KEY=...\nfrom chatlas import ChatGroq\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatGroq()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport GROQ_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html#prerequisites",
    "href": "reference/ChatGroq.html#prerequisites",
    "title": "ChatGroq",
    "section": "",
    "text": "API key\n\n\n\nSign up at https://groq.com to get an API key.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html#examples",
    "href": "reference/ChatGroq.html#examples",
    "title": "ChatGroq",
    "section": "",
    "text": "import os\nfrom chatlas import ChatGroq\n\nchat = ChatGroq(api_key=os.getenv(\"GROQ_API_KEY\"))\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html#parameters",
    "href": "reference/ChatGroq.html#parameters",
    "title": "ChatGroq",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the GROQ_API_KEY environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses Groq‚Äôs API.\n'https://api.groq.com/openai/v1'\n\n\nseed\nOptional[int] | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html#returns",
    "href": "reference/ChatGroq.html#returns",
    "title": "ChatGroq",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html#note",
    "href": "reference/ChatGroq.html#note",
    "title": "ChatGroq",
    "section": "",
    "text": "This function is a lightweight wrapper around ChatOpenAI with the defaults tweaked for groq.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/ChatGroq.html#note-1",
    "href": "reference/ChatGroq.html#note-1",
    "title": "ChatGroq",
    "section": "",
    "text": "Pasting an API key into a chat constructor (e.g., ChatGroq(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nGROQ_API_KEY=...\nfrom chatlas import ChatGroq\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatGroq()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport GROQ_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatGroq"
    ]
  },
  {
    "objectID": "reference/types.TokenUsage.html",
    "href": "reference/types.TokenUsage.html",
    "title": "types.TokenUsage",
    "section": "",
    "text": "types.TokenUsage\ntypes.TokenUsage()\nToken usage for a given provider (name).",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.TokenUsage"
    ]
  },
  {
    "objectID": "reference/types.ChatResponse.html",
    "href": "reference/types.ChatResponse.html",
    "title": "types.ChatResponse",
    "section": "",
    "text": "types.ChatResponse(generator)\nChat response object.\nAn object that, when displayed, will simulatenously consume (if not already consumed) and display the response in a streaming fashion.\nThis is useful for interactive use: if the object is displayed, it can be viewed as it is being generated. And, if the object is not displayed, it can act like an iterator that can be consumed by something else.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncontent\nstr\nThe content of the chat response.\n\n\n\n\n\n\nconsumed Whether the response has been consumed. If the response has been fully consumed, then it can no longer be iterated over, but the content can still be retrieved (via the content attribute).\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_content\nGet the chat response content as a string.\n\n\n\n\n\ntypes.ChatResponse.get_content()\nGet the chat response content as a string.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponse"
    ]
  },
  {
    "objectID": "reference/types.ChatResponse.html#attributes",
    "href": "reference/types.ChatResponse.html#attributes",
    "title": "types.ChatResponse",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ncontent\nstr\nThe content of the chat response.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponse"
    ]
  },
  {
    "objectID": "reference/types.ChatResponse.html#properties",
    "href": "reference/types.ChatResponse.html#properties",
    "title": "types.ChatResponse",
    "section": "",
    "text": "consumed Whether the response has been consumed. If the response has been fully consumed, then it can no longer be iterated over, but the content can still be retrieved (via the content attribute).",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponse"
    ]
  },
  {
    "objectID": "reference/types.ChatResponse.html#methods",
    "href": "reference/types.ChatResponse.html#methods",
    "title": "types.ChatResponse",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_content\nGet the chat response content as a string.\n\n\n\n\n\ntypes.ChatResponse.get_content()\nGet the chat response content as a string.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ChatResponse"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html",
    "href": "reference/ChatPerplexity.html",
    "title": "ChatPerplexity",
    "section": "",
    "text": "ChatPerplexity(\n    system_prompt=None,\n    turns=None,\n    model=None,\n    api_key=None,\n    base_url='https://api.perplexity.ai/',\n    seed=MISSING,\n    kwargs=None,\n)\nChat with a model hosted on perplexity.ai.\nPerplexity AI is a platform for running LLMs that are capable of searching the web in real-time to help them answer questions with information that may not have been available when the model was trained.\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nSign up at https://www.perplexity.ai to get an API key.\n\n\n\n\n\nimport os\nfrom chatlas import ChatPerplexity\n\nchat = ChatPerplexity(api_key=os.getenv(\"PERPLEXITY_API_KEY\"))\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the PERPLEXITY_API_KEY environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses Perplexity‚Äôs API.\n'https://api.perplexity.ai/'\n\n\nseed\nOptional[int] | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.\n\n\n\n\n\n\nThis function is a lightweight wrapper around chatlas.ChatOpenAI with the defaults tweaked for perplexity.ai.\n\n\n\nPasting an API key into a chat constructor (e.g., ChatPerplexity(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nPERPLEXITY_API_KEY=...\nfrom chatlas import ChatPerplexity\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatPerplexity()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport PERPLEXITY_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html#prerequisites",
    "href": "reference/ChatPerplexity.html#prerequisites",
    "title": "ChatPerplexity",
    "section": "",
    "text": "API key\n\n\n\nSign up at https://www.perplexity.ai to get an API key.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html#examples",
    "href": "reference/ChatPerplexity.html#examples",
    "title": "ChatPerplexity",
    "section": "",
    "text": "import os\nfrom chatlas import ChatPerplexity\n\nchat = ChatPerplexity(api_key=os.getenv(\"PERPLEXITY_API_KEY\"))\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html#parameters",
    "href": "reference/ChatPerplexity.html#parameters",
    "title": "ChatPerplexity",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the PERPLEXITY_API_KEY environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses Perplexity‚Äôs API.\n'https://api.perplexity.ai/'\n\n\nseed\nOptional[int] | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html#returns",
    "href": "reference/ChatPerplexity.html#returns",
    "title": "ChatPerplexity",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html#note",
    "href": "reference/ChatPerplexity.html#note",
    "title": "ChatPerplexity",
    "section": "",
    "text": "This function is a lightweight wrapper around chatlas.ChatOpenAI with the defaults tweaked for perplexity.ai.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/ChatPerplexity.html#note-1",
    "href": "reference/ChatPerplexity.html#note-1",
    "title": "ChatPerplexity",
    "section": "",
    "text": "Pasting an API key into a chat constructor (e.g., ChatPerplexity(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nPERPLEXITY_API_KEY=...\nfrom chatlas import ChatPerplexity\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatPerplexity()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport PERPLEXITY_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatPerplexity"
    ]
  },
  {
    "objectID": "reference/types.ContentToolResult.html",
    "href": "reference/types.ContentToolResult.html",
    "title": "types.ContentToolResult",
    "section": "",
    "text": "types.ContentToolResult()\nThe result of calling a tool/function\nA content type representing the result of a tool function call. When a model requests a tool function, Chat will create, (optionally) echo, (optionally) yield, and store this content type in the chat history.\nA tool function may also construct an instance of this class and return it. This is useful for a tool that wishes to customize how the result is handled (e.g., the format of the value sent to the model).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\n\nThe return value of the tool/function.\nrequired\n\n\nmodel_format\n\nThe format used for sending the value to the model. The default, \"auto\", first attempts to format the value as a JSON string. If that fails, it gets converted to a string via str(). To force orjson.dumps() or str(), set to \"json\" or \"str\". Finally, \"as_is\" is useful for doing your own formatting and/or passing a non-string value (e.g., a list or dict) straight to the model. Non-string values are useful for tools that return images or other ‚Äòknown‚Äô non-text content types.\nrequired\n\n\nerror\n\nAn exception that occurred while invoking the tool. If this is set, the error message sent to the model and the value is ignored.\nrequired\n\n\nextra\n\nAdditional data associated with the tool result that isn‚Äôt sent to the model.\nrequired\n\n\nrequest\n\nNot intended to be used directly. It will be set when the :class:~chatlas.Chat invokes the tool.\nrequired\n\n\n\n\n\n\nWhen model_format is \"json\" (or \"auto\"), and the value has a .to_json()/.to_dict() method, those methods are called to obtain the JSON representation of the value. This is convenient for classes, like pandas.DataFrame, that have a .to_json() method, but don‚Äôt necessarily dump to JSON directly. If this happens to not be the desired behavior, set model_format=\"as_is\" return the desired value as-is.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_model_value\nGet the actual value sent to the model.\n\n\ntagify\nA method for rendering this object via htmltools/shiny.\n\n\n\n\n\ntypes.ContentToolResult.get_model_value()\nGet the actual value sent to the model.\n\n\n\ntypes.ContentToolResult.tagify()\nA method for rendering this object via htmltools/shiny.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolResult"
    ]
  },
  {
    "objectID": "reference/types.ContentToolResult.html#parameters",
    "href": "reference/types.ContentToolResult.html#parameters",
    "title": "types.ContentToolResult",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nvalue\n\nThe return value of the tool/function.\nrequired\n\n\nmodel_format\n\nThe format used for sending the value to the model. The default, \"auto\", first attempts to format the value as a JSON string. If that fails, it gets converted to a string via str(). To force orjson.dumps() or str(), set to \"json\" or \"str\". Finally, \"as_is\" is useful for doing your own formatting and/or passing a non-string value (e.g., a list or dict) straight to the model. Non-string values are useful for tools that return images or other ‚Äòknown‚Äô non-text content types.\nrequired\n\n\nerror\n\nAn exception that occurred while invoking the tool. If this is set, the error message sent to the model and the value is ignored.\nrequired\n\n\nextra\n\nAdditional data associated with the tool result that isn‚Äôt sent to the model.\nrequired\n\n\nrequest\n\nNot intended to be used directly. It will be set when the :class:~chatlas.Chat invokes the tool.\nrequired",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolResult"
    ]
  },
  {
    "objectID": "reference/types.ContentToolResult.html#note",
    "href": "reference/types.ContentToolResult.html#note",
    "title": "types.ContentToolResult",
    "section": "",
    "text": "When model_format is \"json\" (or \"auto\"), and the value has a .to_json()/.to_dict() method, those methods are called to obtain the JSON representation of the value. This is convenient for classes, like pandas.DataFrame, that have a .to_json() method, but don‚Äôt necessarily dump to JSON directly. If this happens to not be the desired behavior, set model_format=\"as_is\" return the desired value as-is.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolResult"
    ]
  },
  {
    "objectID": "reference/types.ContentToolResult.html#methods",
    "href": "reference/types.ContentToolResult.html#methods",
    "title": "types.ContentToolResult",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_model_value\nGet the actual value sent to the model.\n\n\ntagify\nA method for rendering this object via htmltools/shiny.\n\n\n\n\n\ntypes.ContentToolResult.get_model_value()\nGet the actual value sent to the model.\n\n\n\ntypes.ContentToolResult.tagify()\nA method for rendering this object via htmltools/shiny.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ContentToolResult"
    ]
  },
  {
    "objectID": "reference/ChatDatabricks.html",
    "href": "reference/ChatDatabricks.html",
    "title": "ChatDatabricks",
    "section": "",
    "text": "ChatDatabricks(\n    system_prompt=None,\n    model=None,\n    turns=None,\n    workspace_client=None,\n)\nChat with a model hosted on Databricks.\nDatabricks provides out-of-the-box access to a number of foundation models and can also serve as a gateway for external models hosted by a third party.\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatDatabricks requires the databricks-sdk package: pip install \"chatlas[databricks]\".\n\n\n\n\n\n\n\n\nAuthentication\n\n\n\nchatlas delegates to the databricks-sdk package for authentication with Databricks. As such, you can use any of the authentication methods discussed here:\nhttps://docs.databricks.com/aws/en/dev-tools/sdk-python#authentication\nNote that Python-specific article points to this language-agnostic ‚Äúunified‚Äù approach to authentication:\nhttps://docs.databricks.com/aws/en/dev-tools/auth/unified-auth\nThere, you‚Äôll find all the options listed, but a simple approach that generally works well is to set the following environment variables:\n\nDATABRICKS_HOST: The Databricks host URL for either the Databricks workspace endpoint or the Databricks accounts endpoint.\nDATABRICKS_TOKEN: The Databricks personal access token.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nworkspace_client\nOptional['WorkspaceClient']\nA databricks.sdk.WorkspaceClient() to use for the connection. If not provided, a new client will be created.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatDatabricks"
    ]
  },
  {
    "objectID": "reference/ChatDatabricks.html#prerequisites",
    "href": "reference/ChatDatabricks.html#prerequisites",
    "title": "ChatDatabricks",
    "section": "",
    "text": "Python requirements\n\n\n\nChatDatabricks requires the databricks-sdk package: pip install \"chatlas[databricks]\".\n\n\n\n\n\n\n\n\nAuthentication\n\n\n\nchatlas delegates to the databricks-sdk package for authentication with Databricks. As such, you can use any of the authentication methods discussed here:\nhttps://docs.databricks.com/aws/en/dev-tools/sdk-python#authentication\nNote that Python-specific article points to this language-agnostic ‚Äúunified‚Äù approach to authentication:\nhttps://docs.databricks.com/aws/en/dev-tools/auth/unified-auth\nThere, you‚Äôll find all the options listed, but a simple approach that generally works well is to set the following environment variables:\n\nDATABRICKS_HOST: The Databricks host URL for either the Databricks workspace endpoint or the Databricks accounts endpoint.\nDATABRICKS_TOKEN: The Databricks personal access token.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatDatabricks"
    ]
  },
  {
    "objectID": "reference/ChatDatabricks.html#parameters",
    "href": "reference/ChatDatabricks.html#parameters",
    "title": "ChatDatabricks",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nmodel\nOptional[str]\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nworkspace_client\nOptional['WorkspaceClient']\nA databricks.sdk.WorkspaceClient() to use for the connection. If not provided, a new client will be created.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatDatabricks"
    ]
  },
  {
    "objectID": "reference/ChatDatabricks.html#returns",
    "href": "reference/ChatDatabricks.html#returns",
    "title": "ChatDatabricks",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatDatabricks"
    ]
  },
  {
    "objectID": "reference/token_usage.html",
    "href": "reference/token_usage.html",
    "title": "token_usage",
    "section": "",
    "text": "token_usage()\nReport on token usage in the current session\nCall this function to find out the cumulative number of tokens that you have sent and received in the current session.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist[TokenUsage] | None\nA list of dictionaries with the following keys: ‚Äúname‚Äù, ‚Äúinput‚Äù, and ‚Äúoutput‚Äù. If no tokens have been logged, then None is returned.",
    "crumbs": [
      "Reference",
      "Query token usage",
      "token_usage"
    ]
  },
  {
    "objectID": "reference/token_usage.html#returns",
    "href": "reference/token_usage.html#returns",
    "title": "token_usage",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nlist[TokenUsage] | None\nA list of dictionaries with the following keys: ‚Äúname‚Äù, ‚Äúinput‚Äù, and ‚Äúoutput‚Äù. If no tokens have been logged, then None is returned.",
    "crumbs": [
      "Reference",
      "Query token usage",
      "token_usage"
    ]
  },
  {
    "objectID": "reference/content_image_plot.html",
    "href": "reference/content_image_plot.html",
    "title": "content_image_plot",
    "section": "",
    "text": "content_image_plot(width=768, height=768, dpi=72)\nEncode the current matplotlib plot as an image for chat input.\nThis function captures the current matplotlib plot, resizes it to the specified dimensions, and prepares it for chat input.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nThe desired width of the output image in pixels.\n768\n\n\nheight\nint\nThe desired height of the output image in pixels.\n768\n\n\ndpi\nint\nThe DPI (dots per inch) of the output image.\n72\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf width or height is not a positive integer.\n\n\n\n\n\n\nfrom chatlas import ChatOpenAI, content_image_plot\nimport matplotlib.pyplot as plt\n\nplt.scatter(faithful[\"eruptions\"], faithful[\"waiting\"])\nchat = ChatOpenAI()\nchat.chat(\n    \"Describe this plot in one paragraph, as suitable for inclusion in \"\n    \"alt-text. You should briefly describe the plot type, the axes, and \"\n    \"2-5 major visual patterns.\",\n    content_image_plot(),\n)",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_plot"
    ]
  },
  {
    "objectID": "reference/content_image_plot.html#parameters",
    "href": "reference/content_image_plot.html#parameters",
    "title": "content_image_plot",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nwidth\nint\nThe desired width of the output image in pixels.\n768\n\n\nheight\nint\nThe desired height of the output image in pixels.\n768\n\n\ndpi\nint\nThe DPI (dots per inch) of the output image.\n72",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_plot"
    ]
  },
  {
    "objectID": "reference/content_image_plot.html#returns",
    "href": "reference/content_image_plot.html#returns",
    "title": "content_image_plot",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_plot"
    ]
  },
  {
    "objectID": "reference/content_image_plot.html#raises",
    "href": "reference/content_image_plot.html#raises",
    "title": "content_image_plot",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nValueError\nIf width or height is not a positive integer.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_plot"
    ]
  },
  {
    "objectID": "reference/content_image_plot.html#examples",
    "href": "reference/content_image_plot.html#examples",
    "title": "content_image_plot",
    "section": "",
    "text": "from chatlas import ChatOpenAI, content_image_plot\nimport matplotlib.pyplot as plt\n\nplt.scatter(faithful[\"eruptions\"], faithful[\"waiting\"])\nchat = ChatOpenAI()\nchat.chat(\n    \"Describe this plot in one paragraph, as suitable for inclusion in \"\n    \"alt-text. You should briefly describe the plot type, the axes, and \"\n    \"2-5 major visual patterns.\",\n    content_image_plot(),\n)",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_plot"
    ]
  },
  {
    "objectID": "reference/content_image_file.html",
    "href": "reference/content_image_file.html",
    "title": "content_image_file",
    "section": "",
    "text": "content_image_file(path, content_type='auto', resize=MISSING)\nEncode image content from a file for chat input.\nThis function is used to prepare image files for input to the chatbot. It can handle various image formats and provides options for resizing.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nThe path to the image file to include in the chat input.\nrequired\n\n\ncontent_type\nLiteral['auto', ImageContentTypes]\nThe content type of the image (e.g., \"image/png\"). If \"auto\", the content type is inferred from the file extension.\n'auto'\n\n\nresize\nUnion[Literal['low', 'high', 'none'], str, MISSING_TYPE]\nResizing option for the image. Can be: - \"low\": Resize to fit within 512x512 - \"high\": Resize to fit within 2000x768 or 768x2000 - \"none\": No resizing - Custom string (e.g., \"200x200\", \"300x200&gt;!\", etc.)\nMISSING\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.\n\n\n\n\n\n\nfrom chatlas import ChatOpenAI, content_image_file\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_file(\"path/to/image.png\"),\n)\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf the specified file does not exist.\n\n\n\nValueError\nIf the file extension is unsupported or the resize option is invalid.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_file"
    ]
  },
  {
    "objectID": "reference/content_image_file.html#parameters",
    "href": "reference/content_image_file.html#parameters",
    "title": "content_image_file",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npath\nstr\nThe path to the image file to include in the chat input.\nrequired\n\n\ncontent_type\nLiteral['auto', ImageContentTypes]\nThe content type of the image (e.g., \"image/png\"). If \"auto\", the content type is inferred from the file extension.\n'auto'\n\n\nresize\nUnion[Literal['low', 'high', 'none'], str, MISSING_TYPE]\nResizing option for the image. Can be: - \"low\": Resize to fit within 512x512 - \"high\": Resize to fit within 2000x768 or 768x2000 - \"none\": No resizing - Custom string (e.g., \"200x200\", \"300x200&gt;!\", etc.)\nMISSING",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_file"
    ]
  },
  {
    "objectID": "reference/content_image_file.html#returns",
    "href": "reference/content_image_file.html#returns",
    "title": "content_image_file",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_file"
    ]
  },
  {
    "objectID": "reference/content_image_file.html#examples",
    "href": "reference/content_image_file.html#examples",
    "title": "content_image_file",
    "section": "",
    "text": "from chatlas import ChatOpenAI, content_image_file\n\nchat = ChatOpenAI()\nchat.chat(\n    \"What do you see in this image?\",\n    content_image_file(\"path/to/image.png\"),\n)",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_file"
    ]
  },
  {
    "objectID": "reference/content_image_file.html#raises",
    "href": "reference/content_image_file.html#raises",
    "title": "content_image_file",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nFileNotFoundError\nIf the specified file does not exist.\n\n\n\nValueError\nIf the file extension is unsupported or the resize option is invalid.",
    "crumbs": [
      "Reference",
      "Image input",
      "content_image_file"
    ]
  },
  {
    "objectID": "reference/content_pdf_url.html",
    "href": "reference/content_pdf_url.html",
    "title": "content_pdf_url",
    "section": "",
    "text": "content_pdf_url(url)\nUse a remote PDF for input to a chat.\nNot all providers support PDF input, so check the documentation for the provider you are using.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nA URL to a remote PDF file.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "PDF input",
      "content_pdf_url"
    ]
  },
  {
    "objectID": "reference/content_pdf_url.html#parameters",
    "href": "reference/content_pdf_url.html#parameters",
    "title": "content_pdf_url",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nurl\nstr\nA URL to a remote PDF file.\nrequired",
    "crumbs": [
      "Reference",
      "PDF input",
      "content_pdf_url"
    ]
  },
  {
    "objectID": "reference/content_pdf_url.html#returns",
    "href": "reference/content_pdf_url.html#returns",
    "title": "content_pdf_url",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\n[](~chatlas.types.Content)\nContent suitable for a Turn object.",
    "crumbs": [
      "Reference",
      "PDF input",
      "content_pdf_url"
    ]
  },
  {
    "objectID": "reference/types.MISSING.html",
    "href": "reference/types.MISSING.html",
    "title": "types.MISSING",
    "section": "",
    "text": "types.MISSING\ntypes.MISSING",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.MISSING"
    ]
  },
  {
    "objectID": "reference/ChatOpenAI.html",
    "href": "reference/ChatOpenAI.html",
    "title": "ChatOpenAI",
    "section": "",
    "text": "ChatOpenAI(\n    system_prompt=None,\n    turns=None,\n    model=None,\n    api_key=None,\n    base_url='https://api.openai.com/v1',\n    seed=MISSING,\n    kwargs=None,\n)\nChat with an OpenAI model.\nOpenAI provides a number of chat based models under the ChatGPT moniker.\n\n\n\n\n\n\n\n\nAPI key\n\n\n\nNote that a ChatGPT Plus membership does not give you the ability to call models via the API. You will need to go to the developer platform to sign up (and pay for) a developer account that will give you an API key that you can use with this package.\n\n\n\n\n\nimport os\nfrom chatlas import ChatOpenAI\n\nchat = ChatOpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\n'Optional[ChatModel | str]'\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the OPENAI_API_KEY environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses OpenAI.\n'https://api.openai.com/v1'\n\n\nseed\nint | None | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.\n\n\n\n\n\n\nPasting an API key into a chat constructor (e.g., ChatOpenAI(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nOPENAI_API_KEY=...\nfrom chatlas import ChatOpenAI\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatOpenAI()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport OPENAI_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatOpenAI.html#prerequisites",
    "href": "reference/ChatOpenAI.html#prerequisites",
    "title": "ChatOpenAI",
    "section": "",
    "text": "API key\n\n\n\nNote that a ChatGPT Plus membership does not give you the ability to call models via the API. You will need to go to the developer platform to sign up (and pay for) a developer account that will give you an API key that you can use with this package.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatOpenAI.html#examples",
    "href": "reference/ChatOpenAI.html#examples",
    "title": "ChatOpenAI",
    "section": "",
    "text": "import os\nfrom chatlas import ChatOpenAI\n\nchat = ChatOpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatOpenAI.html#parameters",
    "href": "reference/ChatOpenAI.html#parameters",
    "title": "ChatOpenAI",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nmodel\n'Optional[ChatModel | str]'\nThe model to use for the chat. The default, None, will pick a reasonable default, and warn you about it. We strongly recommend explicitly choosing a model for all but the most casual use.\nNone\n\n\napi_key\nOptional[str]\nThe API key to use for authentication. You generally should not supply this directly, but instead set the OPENAI_API_KEY environment variable.\nNone\n\n\nbase_url\nstr\nThe base URL to the endpoint; the default uses OpenAI.\n'https://api.openai.com/v1'\n\n\nseed\nint | None | MISSING_TYPE\nOptional integer seed that ChatGPT uses to try and make output more reproducible.\nMISSING\n\n\nkwargs\nOptional['ChatClientArgs']\nAdditional arguments to pass to the openai.OpenAI() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatOpenAI.html#returns",
    "href": "reference/ChatOpenAI.html#returns",
    "title": "ChatOpenAI",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA chat object that retains the state of the conversation.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOpenAI"
    ]
  },
  {
    "objectID": "reference/ChatOpenAI.html#note",
    "href": "reference/ChatOpenAI.html#note",
    "title": "ChatOpenAI",
    "section": "",
    "text": "Pasting an API key into a chat constructor (e.g., ChatOpenAI(api_key=\"...\")) is the simplest way to get started, and is fine for interactive use, but is problematic for code that may be shared with others.\nInstead, consider using environment variables or a configuration file to manage your credentials. One popular way to manage credentials is to use a .env file to store your credentials, and then use the python-dotenv package to load them into your environment.\npip install python-dotenv\n# .env\nOPENAI_API_KEY=...\nfrom chatlas import ChatOpenAI\nfrom dotenv import load_dotenv\n\nload_dotenv()\nchat = ChatOpenAI()\nchat.console()\nAnother, more general, solution is to load your environment variables into the shell before starting Python (maybe in a .bashrc, .zshrc, etc. file):\nexport OPENAI_API_KEY=...",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatOpenAI"
    ]
  },
  {
    "objectID": "reference/types.ImageContentTypes.html",
    "href": "reference/types.ImageContentTypes.html",
    "title": "types.ImageContentTypes",
    "section": "",
    "text": "types.ImageContentTypes\ntypes.ImageContentTypes\nAllowable content types for images.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.ImageContentTypes"
    ]
  },
  {
    "objectID": "reference/types.MISSING_TYPE.html",
    "href": "reference/types.MISSING_TYPE.html",
    "title": "types.MISSING_TYPE",
    "section": "",
    "text": "types.MISSING_TYPE\ntypes.MISSING_TYPE()\nA singleton representing a missing value.",
    "crumbs": [
      "Reference",
      "User-facing types",
      "types.MISSING_TYPE"
    ]
  },
  {
    "objectID": "reference/ChatBedrockAnthropic.html",
    "href": "reference/ChatBedrockAnthropic.html",
    "title": "ChatBedrockAnthropic",
    "section": "",
    "text": "ChatBedrockAnthropic(\n    model=None,\n    max_tokens=4096,\n    aws_secret_key=None,\n    aws_access_key=None,\n    aws_region=None,\n    aws_profile=None,\n    aws_session_token=None,\n    base_url=None,\n    system_prompt=None,\n    turns=None,\n    kwargs=None,\n)\nChat with an AWS bedrock model.\nAWS Bedrock provides a number of chat based models, including those Anthropic‚Äôs Claude.\n\n\n\n\n\n\n\n\nAWS credentials\n\n\n\nConsider using the approach outlined in this guide to manage your AWS credentials: https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatBedrockAnthropic, requires the anthropic package with the bedrock extras: pip install \"chatlas[bedrock-anthropic]\"\n\n\n\n\n\nfrom chatlas import ChatBedrockAnthropic\n\nchat = ChatBedrockAnthropic(\n    aws_profile=\"...\",\n    aws_region=\"us-east\",\n    aws_secret_key=\"...\",\n    aws_access_key=\"...\",\n    aws_session_token=\"...\",\n)\nchat.chat(\"What is the capital of France?\")\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmodel\nOptional[str]\nThe model to use for the chat.\nNone\n\n\nmax_tokens\nint\nMaximum number of tokens to generate before stopping.\n4096\n\n\naws_secret_key\nOptional[str]\nThe AWS secret key to use for authentication.\nNone\n\n\naws_access_key\nOptional[str]\nThe AWS access key to use for authentication.\nNone\n\n\naws_region\nOptional[str]\nThe AWS region to use. Defaults to the AWS_REGION environment variable. If that is not set, defaults to 'us-east-1'.\nNone\n\n\naws_profile\nOptional[str]\nThe AWS profile to use.\nNone\n\n\naws_session_token\nOptional[str]\nThe AWS session token to use.\nNone\n\n\nbase_url\nOptional[str]\nThe base URL to use. Defaults to the ANTHROPIC_BEDROCK_BASE_URL environment variable. If that is not set, defaults to f\"https://bedrock-runtime.{aws_region}.amazonaws.com\".\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nkwargs\nOptional['ChatBedrockClientArgs']\nAdditional arguments to pass to the anthropic.AnthropicBedrock() client constructor.\nNone\n\n\n\n\n\n\nIf you encounter 400 or 403 errors when trying to use the model, keep the following in mind:\n\n\n\n\n\n\nIncorrect model name\n\n\n\nIf the model name is completely incorrect, you‚Äôll see an error like Error code: 400 - {'message': 'The provided model identifier is invalid.'}\nMake sure the model name is correct and active in the specified region.\n\n\n\n\n\n\n\n\nModels are region specific\n\n\n\nIf you encounter errors similar to Error code: 403 - {'message': \"You don't have access to the model with the specified model ID.\"}, make sure your model is active in the relevant aws_region.\nKeep in mind, if aws_region is not specified, and AWS_REGION is not set, the region defaults to us-east-1, which may not match to your AWS config‚Äôs default region.\n\n\n\n\n\n\n\n\nCross region inference ID\n\n\n\nIn some cases, even if you have the right model and the right region, you may still encounter an error like Error code: 400 - {'message': 'Invocation of model ID anthropic.claude-3-5-sonnet-20240620-v1:0 with on-demand throughput isn't supported. Retry your request with the ID or ARN of an inference profile that contains this model.'}\nIn this case, you‚Äôll need to look up the ‚Äòcross region inference ID‚Äô for your model. This might required opening your aws-console and navigating to the ‚ÄòAnthropic Bedrock‚Äô service page. From there, go to the ‚Äòcross region inference‚Äô tab and copy the relevant ID.\nFor example, if the desired model ID is anthropic.claude-3-5-sonnet-20240620-v1:0, the cross region ID might look something like us.anthropic.claude-3-5-sonnet-20240620-v1:0.\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatBedrockAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatBedrockAnthropic.html#prerequisites",
    "href": "reference/ChatBedrockAnthropic.html#prerequisites",
    "title": "ChatBedrockAnthropic",
    "section": "",
    "text": "AWS credentials\n\n\n\nConsider using the approach outlined in this guide to manage your AWS credentials: https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html\n\n\n\n\n\n\n\n\nPython requirements\n\n\n\nChatBedrockAnthropic, requires the anthropic package with the bedrock extras: pip install \"chatlas[bedrock-anthropic]\"",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatBedrockAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatBedrockAnthropic.html#examples",
    "href": "reference/ChatBedrockAnthropic.html#examples",
    "title": "ChatBedrockAnthropic",
    "section": "",
    "text": "from chatlas import ChatBedrockAnthropic\n\nchat = ChatBedrockAnthropic(\n    aws_profile=\"...\",\n    aws_region=\"us-east\",\n    aws_secret_key=\"...\",\n    aws_access_key=\"...\",\n    aws_session_token=\"...\",\n)\nchat.chat(\"What is the capital of France?\")",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatBedrockAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatBedrockAnthropic.html#parameters",
    "href": "reference/ChatBedrockAnthropic.html#parameters",
    "title": "ChatBedrockAnthropic",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nmodel\nOptional[str]\nThe model to use for the chat.\nNone\n\n\nmax_tokens\nint\nMaximum number of tokens to generate before stopping.\n4096\n\n\naws_secret_key\nOptional[str]\nThe AWS secret key to use for authentication.\nNone\n\n\naws_access_key\nOptional[str]\nThe AWS access key to use for authentication.\nNone\n\n\naws_region\nOptional[str]\nThe AWS region to use. Defaults to the AWS_REGION environment variable. If that is not set, defaults to 'us-east-1'.\nNone\n\n\naws_profile\nOptional[str]\nThe AWS profile to use.\nNone\n\n\naws_session_token\nOptional[str]\nThe AWS session token to use.\nNone\n\n\nbase_url\nOptional[str]\nThe base URL to use. Defaults to the ANTHROPIC_BEDROCK_BASE_URL environment variable. If that is not set, defaults to f\"https://bedrock-runtime.{aws_region}.amazonaws.com\".\nNone\n\n\nsystem_prompt\nOptional[str]\nA system prompt to set the behavior of the assistant.\nNone\n\n\nturns\nOptional[list[Turn]]\nA list of turns to start the chat with (i.e., continuing a previous conversation). If not provided, the conversation begins from scratch. Do not provide non-None values for both turns and system_prompt. Each message in the list should be a dictionary with at least role (usually system, user, or assistant, but tool is also possible). Normally there is also a content field, which is a string.\nNone\n\n\nkwargs\nOptional['ChatBedrockClientArgs']\nAdditional arguments to pass to the anthropic.AnthropicBedrock() client constructor.\nNone",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatBedrockAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatBedrockAnthropic.html#troubleshooting",
    "href": "reference/ChatBedrockAnthropic.html#troubleshooting",
    "title": "ChatBedrockAnthropic",
    "section": "",
    "text": "If you encounter 400 or 403 errors when trying to use the model, keep the following in mind:\n\n\n\n\n\n\nIncorrect model name\n\n\n\nIf the model name is completely incorrect, you‚Äôll see an error like Error code: 400 - {'message': 'The provided model identifier is invalid.'}\nMake sure the model name is correct and active in the specified region.\n\n\n\n\n\n\n\n\nModels are region specific\n\n\n\nIf you encounter errors similar to Error code: 403 - {'message': \"You don't have access to the model with the specified model ID.\"}, make sure your model is active in the relevant aws_region.\nKeep in mind, if aws_region is not specified, and AWS_REGION is not set, the region defaults to us-east-1, which may not match to your AWS config‚Äôs default region.\n\n\n\n\n\n\n\n\nCross region inference ID\n\n\n\nIn some cases, even if you have the right model and the right region, you may still encounter an error like Error code: 400 - {'message': 'Invocation of model ID anthropic.claude-3-5-sonnet-20240620-v1:0 with on-demand throughput isn't supported. Retry your request with the ID or ARN of an inference profile that contains this model.'}\nIn this case, you‚Äôll need to look up the ‚Äòcross region inference ID‚Äô for your model. This might required opening your aws-console and navigating to the ‚ÄòAnthropic Bedrock‚Äô service page. From there, go to the ‚Äòcross region inference‚Äô tab and copy the relevant ID.\nFor example, if the desired model ID is anthropic.claude-3-5-sonnet-20240620-v1:0, the cross region ID might look something like us.anthropic.claude-3-5-sonnet-20240620-v1:0.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatBedrockAnthropic"
    ]
  },
  {
    "objectID": "reference/ChatBedrockAnthropic.html#returns",
    "href": "reference/ChatBedrockAnthropic.html#returns",
    "title": "ChatBedrockAnthropic",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nChat\nA Chat object.",
    "crumbs": [
      "Reference",
      "Chat model providers",
      "ChatBedrockAnthropic"
    ]
  },
  {
    "objectID": "prompt-design.html",
    "href": "prompt-design.html",
    "title": "Prompt design",
    "section": "",
    "text": "This article gives you some advice about how to use chatlas to write prompts. We‚Äôll work through two hopefully relevant examples: a prompt that generates code and another that extracts structured data. If you‚Äôve never written a prompt, I‚Äôd highly recommend reading Ethan Mollick‚Äôs Getting started with AI: Good enough prompting. I think understanding his analogy about how AI works will really help you get started:\nAs well as learning general prompt design skills, it‚Äôs also a good idea to read any specific advice for the model that you‚Äôre using. Here are some pointers to the prompt design guides of some of the most popular models:\nIf you have a claude account, you can use its prompt-generator. It‚Äôs specifically tailored for Claude, but I suspect it will help you with many other LLMs, or at least give you some ideas as to what else to include in your prompt."
  },
  {
    "objectID": "prompt-design.html#best-practices",
    "href": "prompt-design.html#best-practices",
    "title": "Prompt design",
    "section": "Best practices",
    "text": "Best practices\nIt‚Äôs highly likely that you‚Äôll end up writing long, possibly multi-page prompts. To ensure your success with this task, we have two recommendations. First, put each prompt its own, separate file. Second, write the prompts using markdown. The reason to use markdown is that it‚Äôs quite readable to LLMs (and humans), and it allows you to do things like use headers to divide up a prompt into sections and itemised lists to enumerate multiple options. You can see some examples of this style of prompt here:\n\nhttps://github.com/posit-dev/shiny-assistant/blob/main/shinyapp/app_prompt_python.md\nhttps://github.com/jcheng5/py-sidebot/blob/main/prompt.md\nhttps://github.com/simonpcouch/pal/tree/main/inst/prompts\nhttps://github.com/cpsievert/aidea/blob/main/inst/app/prompt.md\n\nIn terms of file names, if you only have one prompt in your project, call it prompt.md. If you have multiple prompts, give them informative names like prompt-extract-metadata.md or prompt-summarize-text.md. If you‚Äôre writing a package, put your prompt(s) in a prompts directory, otherwise it‚Äôs fine to put them in the project‚Äôs root directory.\nYour prompts are going to change over time, so we‚Äôd highly recommend commiting them to a git repo. That will ensure that you can easily see what has changed, and that if you accidentally make a mistake you can easily roll back to a known good verison.\nIf your prompt includes dynamic data, you could use something like f-strings to insert variables, but using { and } for templating won‚Äôt work well when the prompt contains JSON. Instead, consider using chatlas.interpolate() (or chatlas.interpolate_file()), which uses { } instead of { } to make it easier to work with JSON.\nAs you iterate on the prompt, it‚Äôs a good idea to build up a small set of challenging examples that you can regularly re-check with your latest version of the prompt. Currently you‚Äôll need to do this by hand, but we hope to eventually also provide tools that‚Äôll help you do this a little more formally.\nUnfortunately, you won‚Äôt see these best practices in action in this article since we‚Äôre keeping the prompts short and inline to make it easier for you to grok what‚Äôs going on."
  },
  {
    "objectID": "prompt-design.html#code-generation",
    "href": "prompt-design.html#code-generation",
    "title": "Prompt design",
    "section": "Code generation",
    "text": "Code generation\nLet‚Äôs explore prompt design for a simple code generation task:\n\nfrom chatlas import ChatAnthropic, ChatOpenAI\n\nquestion = \"\"\"\n  How can I compute the mean and median of variables a, b, c, and so on,\n  all the way up to z, grouped by age and sex.\n\"\"\"\n\n\nBasic flavour\nWhen I don‚Äôt provide a system prompt, I sometimes get answers in a different language (like R):\n\nchat = ChatAnthropic()\n_ = chat.chat(question)\n\n\n\n\n\n\n\nHere‚Äôs how to compute mean and median for variables a through z, grouped by age and sex:\n# Using dplyr\nlibrary(dplyr)\n\ndf %&gt;%\n  group_by(age, sex) %&gt;%\n  summarise(across(a:z, list(\n    mean = ~mean(., na.rm = TRUE),\n    median = ~median(., na.rm = TRUE)\n  )))\n\n# Alternative base R approach\naggregate(. ~ age + sex, data = df[,c(\"age\", \"sex\", letters[1:26])], \n         FUN = function(x) c(mean = mean(x), median = median(x)))\nThis will: 1. Group the data by age and sex 2. Calculate both mean and median for each variable a through z 3. Handle missing values with na.rm = TRUE 4. Return a dataframe with results for each age-sex combination\nThe output will have columns for age, sex, and mean/median values for each variable.\n\n\nI can ensure that I always get Python code by providing a system prompt:\n\nchat.system_prompt = \"You are a helpful Python (not R) programming assistant.\"\n_ = chat.chat(question)\n\n\n\n\n\nHere‚Äôs how to compute mean and median for variables a through z using Python, typically with pandas:\nimport pandas as pd\n\n# Assuming your data is in a DataFrame called df\nresult = df.groupby(['age', 'sex'])[list('abcdefghijklmnopqrstuvwxyz')].agg(['mean', 'median'])\n\n# If you want to reset the index to make age and sex regular columns\nresult = result.reset_index()\nAlternative approach with more explicit control:\nimport pandas as pd\n\n# Create list of column names from a to z\ncols = list('abcdefghijklmnopqrstuvwxyz')\n\n# Group by age and sex, then calculate both statistics\nresult = df.groupby(['age', 'sex'])[cols].agg({\n    col: ['mean', 'median'] for col in cols\n})\n\n# Optional: flatten column names\nresult.columns = ['_'.join(col).strip() for col in result.columns.values]\nresult = result.reset_index()\nThis will: 1. Group your data by age and sex 2. Calculate mean and median for each variable from a to z 3. Create a DataFrame with results where: - Each row represents a unique age-sex combination - Columns show the mean and median for each variable\nNote: This assumes that: - Your DataFrame has columns named a through z - These columns contain numeric values - You have ‚Äòage‚Äô and ‚Äòsex‚Äô columns for grouping\nThe result will handle missing values (NaN) automatically.\n\n\nNote that I‚Äôm using both a system prompt (which defines the general behaviour) and a user prompt (which asks the specific question). You could put all of the content in the user prompt and get similar results, but I think it‚Äôs helpful to use both to cleanly divide the general framing of the response from the specific questions that you want to ask.\nSince I‚Äôm mostly interested in the code, I ask it to drop the explanation:\n\nchat.system_prompt = \"\"\"\n  You are a helpful Python (not R) programming assistant.\n  Just give me the code without any text explanation.\n\"\"\"\n_ = chat.chat(question)\n\n\n\n\n\nimport pandas as pd\n\ncols = list('abcdefghijklmnopqrstuvwxyz')\nresult = df.groupby(['age', 'sex'])[cols].agg(['mean', 'median']).reset_index()\n\n\nIn this case, I seem to mostly get pandas code. But if you want a different style, you can ask for it:\n\nchat.system_prompt = \"\"\"\n  You are a helpful Python (not R) programming assistant who prefers polars to pandas.\n  Just give me the code without any text explanation.\n\"\"\"\n_ = chat.chat(question)\n\n\n\n\n\nimport polars as pl\n\ncols = list('abcdefghijklmnopqrstuvwxyz')\nresult = (df.groupby(['age', 'sex'])\n          .agg([pl.col(c).mean().alias(f'{c}_mean') for c in cols] +\n               [pl.col(c).median().alias(f'{c}_median') for c in cols]))\n\n\n\n\nBe explicit\nIf there‚Äôs something about the output that you don‚Äôt like, you can try being more explicit about it. For example, the code isn‚Äôt styled quite how I like, so I provide more details about what I do want:\n\nchat.system_prompt = \"\"\"\n  You are a helpful Python (not R) programming assistant who prefers siuba to pandas.\n  Just give me the code. I don't want any explanation or sample data.\n  * Spread long function calls across multiple lines.\n  * Where needed, always indent function calls with two spaces.\n  * Always use double quotes for strings.\n\"\"\"\n_ = chat.chat(question)\n\n\n\n\n\nfrom siuba import _, group_by, summarize\nfrom siuba.siu import mean, median\n\nresult = (df\n  &gt;&gt; group_by(_.age, _.sex)\n  &gt;&gt; summarize(**{\n    f\"{col}_{stat}\": stat(getattr(_, col))\n    for col in \"abcdefghijklmnopqrstuvwxyz\"\n    for stat in [mean, median]\n  }))\n\n\nThis still doesn‚Äôt yield exactly the code that I‚Äôd write, but it‚Äôs prety close.\nYou could provide a different prompt if you were looking for more explanation of the code:\n\nchat.system_prompt = \"\"\"\n  You are an an expert Python (not R) programmer and a warm and supportive teacher.\n  Help me understand the code you produce by explaining each function call with\n  a brief comment. For more complicated calls, add documentation to each\n  argument. Just give me the code without any text explanation.\n\"\"\"\n_ = chat.chat(question)\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n# Create list of letters a-z\ncols = list('abcdefghijklmnopqrstuvwxyz')\n\n# Group by age and sex, compute mean and median for all letter columns\nresult = (df.groupby(['age', 'sex'])\n          .agg({col: [np.mean, np.median] for col in cols})  # Dictionary comprehension for aggregations\n          .round(2)  # Round results to 2 decimal places\n          .reset_index())  # Convert age and sex back to regular columns\n\n\n\n\nTeach it about new features\nYou can imagine LLMs as being a sort of an average of the internet at a given point in time. That means they will provide popular answers, which will tend to reflect older coding styles (either because the new features aren‚Äôt in their index, or the older features are so much more popular). So if you want your code to use specific newer language features, you might need to provide the examples yourself:\n\nchat.system_prompt = \"\"\"\n  You are an expert R programmer.\n  Just give me the code; no explanation in text.\n  Use the `.by` argument rather than `group_by()`.\n  dplyr 1.1.0 introduced per-operation grouping with the `.by` argument.\n  e.g., instead of:\n\n  transactions |&gt;\n    group_by(company, year) |&gt;\n    mutate(total = sum(revenue))\n\n  write this:\n  transactions |&gt;\n    mutate(\n      total = sum(revenue),\n      .by = c(company, year)\n    )\n\"\"\"\n_ = chat.chat(question)\n\n\n\n\n\ndf |&gt;\n  summarise(\n    across(a:z, list(\n      mean = \\(x) mean(x, na.rm = TRUE),\n      median = \\(x) median(x, na.rm = TRUE)\n    )),\n    .by = c(age, sex)\n  )"
  },
  {
    "objectID": "prompt-design.html#structured-data",
    "href": "prompt-design.html#structured-data",
    "title": "Prompt design",
    "section": "Structured data",
    "text": "Structured data\nProviding a rich set of examples is a great way to encourage the output to produce exactly what you want. This is known as multi-shot prompting. Below we‚Äôll work through a prompt that I designed to extract structured data from recipes, but the same ideas apply in many other situations.\n\nGetting started\nMy overall goal is to turn a list of ingredients, like the following, into a nicely structured JSON that I can then analyse in Python (e.g.¬†compute the total weight, scale the recipe up or down, or convert the units from volumes to weights).\n\ningredients = \"\"\"\n  ¬æ cup (150g) dark brown sugar\n  2 large eggs\n  ¬æ cup (165g) sour cream\n  ¬Ω cup (113g) unsalted butter, melted\n  1 teaspoon vanilla extract\n  ¬æ teaspoon kosher salt\n  ‚Öì cup (80ml) neutral oil\n  1¬Ω cups (190g) all-purpose flour\n  150g plus 1¬Ω teaspoons sugar\n\"\"\"\nchat = ChatOpenAI(model=\"gpt-4o-mini\")\n\n(This isn‚Äôt the ingredient list for a real recipe but it includes a sampling of styles that I encountered in my project.)\nIf you don‚Äôt have strong feelings about what the data structure should look like, you can start with a very loose prompt and see what you get back. I find this a useful pattern for underspecified problems where the heavy lifting lies with precisely defining the problem you want to solve. Seeing the LLM‚Äôs attempt to create a data structure gives me something to react to, rather than having to start from a blank page.\n\ninstruct_json = \"\"\"\n  You're an expert baker who also loves JSON. I am going to give you a list of\n  ingredients and your job is to return nicely structured JSON. Just return the\n  JSON and no other commentary.\n\"\"\"\nchat.system_prompt = instruct_json\n_ = chat.chat(ingredients)\n\n\n\n\n\n{\n  \"ingredients\": [\n    {\n      \"name\": \"dark brown sugar\",\n      \"amount\": \"¬æ cup\",\n      \"weight\": \"150g\"\n    },\n    {\n      \"name\": \"large eggs\",\n      \"amount\": 2\n    },\n    {\n      \"name\": \"sour cream\",\n      \"amount\": \"¬æ cup\",\n      \"weight\": \"165g\"\n    },\n    {\n      \"name\": \"unsalted butter\",\n      \"amount\": \"¬Ω cup\",\n      \"weight\": \"113g\",\n      \"state\": \"melted\"\n    },\n    {\n      \"name\": \"vanilla extract\",\n      \"amount\": \"1 teaspoon\"\n    },\n    {\n      \"name\": \"kosher salt\",\n      \"amount\": \"¬æ teaspoon\"\n    },\n    {\n      \"name\": \"neutral oil\",\n      \"amount\": \"‚Öì cup\",\n      \"volume\": \"80ml\"\n    },\n    {\n      \"name\": \"all-purpose flour\",\n      \"amount\": \"1¬Ω cups\",\n      \"weight\": \"190g\"\n    },\n    {\n      \"name\": \"sugar\",\n      \"amount\": \"150g plus 1¬Ω teaspoons\"\n    }\n  ]\n}\n\n\n(I don‚Äôt know if the additional colour, ‚ÄúYou‚Äôre an expert baker who also loves JSON‚Äù, does anything, but I like to think this helps the LLM get into the right mindset of a very nerdy baker.)\n\n\nProvide examples\nThis isn‚Äôt a bad start, but I prefer to cook with weight and I only want to see volumes if weight isn‚Äôt available so I provide a couple of examples of what I‚Äôm looking for. I was pleasantly suprised that I can provide the input and output examples in such a loose format.\n\ninstruct_weight = \"\"\"\n  Here are some examples of the sort of output I'm looking for:\n\n  ¬æ cup (150g) dark brown sugar\n  {\"name\": \"dark brown sugar\", \"quantity\": 150, \"unit\": \"g\"}\n\n  ‚Öì cup (80ml) neutral oil\n  {\"name\": \"neutral oil\", \"quantity\": 80, \"unit\": \"ml\"}\n\n  2 t ground cinnamon\n  {\"name\": \"ground cinnamon\", \"quantity\": 2, \"unit\": \"teaspoon\"}\n\"\"\"\n\nchat.system_prompt = instruct_json + \"\\n\" + instruct_weight\n_ = chat.chat(ingredients)\n\n\n\n\n\n{\n  \"ingredients\": [\n    {\n      \"name\": \"dark brown sugar\",\n      \"quantity\": 150,\n      \"unit\": \"g\"\n    },\n    {\n      \"name\": \"large eggs\",\n      \"quantity\": 2\n    },\n    {\n      \"name\": \"sour cream\",\n      \"quantity\": 165,\n      \"unit\": \"g\"\n    },\n    {\n      \"name\": \"unsalted butter\",\n      \"quantity\": 113,\n      \"unit\": \"g\",\n      \"state\": \"melted\"\n    },\n    {\n      \"name\": \"vanilla extract\",\n      \"quantity\": 1,\n      \"unit\": \"teaspoon\"\n    },\n    {\n      \"name\": \"kosher salt\",\n      \"quantity\": 0.75,\n      \"unit\": \"teaspoon\"\n    },\n    {\n      \"name\": \"neutral oil\",\n      \"quantity\": 80,\n      \"unit\": \"ml\"\n    },\n    {\n      \"name\": \"all-purpose flour\",\n      \"quantity\": 190,\n      \"unit\": \"g\"\n    },\n    {\n      \"name\": \"sugar\",\n      \"quantity\": \"150g plus 1¬Ω teaspoons\"\n    }\n  ]\n}\n\n\nJust providing the examples seems to work remarkably well. But I found it useful to also include a description of what the examples are trying to accomplish. I‚Äôm not sure if this helps the LLM or not, but it certainly makes it easier for me to understand the organisation and check that I‚Äôve covered the key pieces I‚Äôm interested in.\n\ninstruct_weight = \"\"\"\n  * If an ingredient has both weight and volume, extract only the weight:\n\n  ¬æ cup (150g) dark brown sugar\n  [\n    {\"name\": \"dark brown sugar\", \"quantity\": 150, \"unit\": \"g\"}\n  ]\n\n* If an ingredient only lists a volume, extract that.\n\n  2 t ground cinnamon\n  ‚Öì cup (80ml) neutral oil\n  [\n    {\"name\": \"ground cinnamon\", \"quantity\": 2, \"unit\": \"teaspoon\"},\n    {\"name\": \"neutral oil\", \"quantity\": 80, \"unit\": \"ml\"}\n  ]\n\"\"\"\n\nThis structure also allows me to give the LLMs a hint about how I want multiple ingredients to be stored, i.e.¬†as an JSON array.\nI then iterated on the prompt, looking at the results from different recipes to get a sense of what the LLM was getting wrong. Much of this felt like I was iterating on my own understanding of the problem as I didn‚Äôt start by knowing exactly how I wanted the data. For example, when I started out I didn‚Äôt really think about all the various ways that ingredients are specified. For later analysis, I always want quantities to be number, even if they were originally fractions, or the if the units aren‚Äôt precise (like a pinch). It made me to realise that some ingredients are unitless.\n\ninstruct_unit = \"\"\"\n* If the unit uses a fraction, convert it to a decimal.\n\n  ‚Öì cup sugar\n  ¬Ω teaspoon salt\n  [\n    {\"name\": \"dark brown sugar\", \"quantity\": 0.33, \"unit\": \"cup\"},\n    {\"name\": \"salt\", \"quantity\": 0.5, \"unit\": \"teaspoon\"}\n  ]\n\n* Quantities are always numbers\n\n  pinch of kosher salt\n  [\n    {\"name\": \"kosher salt\", \"quantity\": 1, \"unit\": \"pinch\"}\n  ]\n\n* Some ingredients don't have a unit.\n  2 eggs\n  1 lime\n  1 apple\n  [\n    {\"name\": \"egg\", \"quantity\": 2},\n    {\"name\": \"lime\", \"quantity\": 1},\n    {\"name\", \"apple\", \"quantity\": 1}\n  ]\n\"\"\"\n\nYou might want to take a look at the full prompt to see what I ended up with.\n\n\nStructured data\nNow that I‚Äôve iterated to get a data structure I like, it seems useful to formalise it and tell the LLM exactly what I‚Äôm looking for when dealing with structured data. This guarantees that the LLM will only return JSON, that the JSON will have the fields that you expect, and that chatlas will convert it into an Python data structure for you.\n\nfrom pydantic import BaseModel, Field\n\nclass Ingredient(BaseModel):\n    \"Ingredient name\"\n    name: str = Field(description=\"Ingredient name\")\n    quantity: float\n    unit: str | None = Field(description=\"Unit of measurement\")\n\nclass Ingredients(BaseModel):\n    items: list[Ingredient]\n\nchat.system_prompt = instruct_json + \"\\n\" + instruct_weight\nchat.extract_data(ingredients, data_model=Ingredients)\n\n{'items': [{'name': 'dark brown sugar', 'quantity': 150, 'unit': 'g'},\n  {'name': 'large eggs', 'quantity': 2, 'unit': None},\n  {'name': 'sour cream', 'quantity': 165, 'unit': 'g'},\n  {'name': 'unsalted butter', 'quantity': 113, 'unit': 'g'},\n  {'name': 'vanilla extract', 'quantity': 1, 'unit': 'teaspoon'},\n  {'name': 'kosher salt', 'quantity': 0.75, 'unit': 'teaspoon'},\n  {'name': 'neutral oil', 'quantity': 80, 'unit': 'ml'},\n  {'name': 'all-purpose flour', 'quantity': 190, 'unit': 'g'},\n  {'name': 'sugar', 'quantity': 150, 'unit': 'g plus 1¬Ω teaspoons'}]}\n\n\n\n\nCapturing raw input\nOne thing that I‚Äôd do next time would also be to include the raw ingredient names in the output. This doesn‚Äôt make much difference in this simple example but it makes it much easier to align the input with the output and to start developing automated measures of how well my prompt is doing.\n\ninstruct_weight_input = \"\"\"\n  * If an ingredient has both weight and volume, extract only the weight:\n\n    ¬æ cup (150g) dark brown sugar\n    [\n      {\"name\": \"dark brown sugar\", \"quantity\": 150, \"unit\": \"g\", \"input\": \"¬æ cup (150g) dark brown sugar\"}\n    ]\n\n  * If an ingredient only lists a volume, extract that.\n\n    2 t ground cinnamon\n    ‚Öì cup (80ml) neutral oil\n    [\n      {\"name\": \"ground cinnamon\", \"quantity\": 2, \"unit\": \"teaspoon\", \"input\": \"2 t ground cinnamon\"},\n      {\"name\": \"neutral oil\", \"quantity\": 80, \"unit\": \"ml\", \"input\": \"‚Öì cup (80ml) neutral oil\"}\n    ]\n\"\"\"\n\nI think this is particularly important if you‚Äôre working with even less structured text. For example, imagine you had this text:\n\nrecipe = \"\"\"\n  In a large bowl, cream together one cup of softened unsalted butter and a\n  quarter cup of white sugar until smooth. Beat in an egg and 1 teaspoon of\n  vanilla extract. Gradually stir in 2 cups of all-purpose flour until the\n  dough forms. Finally, fold in 1 cup of semisweet chocolate chips. Drop\n  spoonfuls of dough onto an ungreased baking sheet and bake at 350¬∞F (175¬∞C)\n  for 10-12 minutes, or until the edges are lightly browned. Let the cookies\n  cool on the baking sheet for a few minutes before transferring to a wire\n  rack to cool completely. Enjoy!\n\"\"\"\n\nIncluding the input text in the output makes it easier to see if it‚Äôs doing a good job:\n\nchat.system_prompt = instruct_json + \"\\n\" + instruct_weight_input\n_ = chat.chat(ingredients)\n\n\n\n\n\n{\n  \"ingredients\": [\n    {\n      \"name\": \"dark brown sugar\",\n      \"quantity\": 150,\n      \"unit\": \"g\",\n      \"input\": \"¬æ cup (150g) dark brown sugar\"\n    },\n    {\n      \"name\": \"large eggs\",\n      \"quantity\": 2,\n      \"input\": \"2 large eggs\"\n    },\n    {\n      \"name\": \"sour cream\",\n      \"quantity\": 165,\n      \"unit\": \"g\",\n      \"input\": \"¬æ cup (165g) sour cream\"\n    },\n    {\n      \"name\": \"unsalted butter\",\n      \"quantity\": 113,\n      \"unit\": \"g\",\n      \"state\": \"melted\",\n      \"input\": \"¬Ω cup (113g) unsalted butter, melted\"\n    },\n    {\n      \"name\": \"vanilla extract\",\n      \"quantity\": 1,\n      \"unit\": \"teaspoon\",\n      \"input\": \"1 teaspoon vanilla extract\"\n    },\n    {\n      \"name\": \"kosher salt\",\n      \"quantity\": 0.75,\n      \"unit\": \"teaspoon\",\n      \"input\": \"¬æ teaspoon kosher salt\"\n    },\n    {\n      \"name\": \"neutral oil\",\n      \"quantity\": 80,\n      \"unit\": \"ml\",\n      \"input\": \"‚Öì cup (80ml) neutral oil\"\n    },\n    {\n      \"name\": \"all-purpose flour\",\n      \"quantity\": 190,\n      \"unit\": \"g\",\n      \"input\": \"1¬Ω cups (190g) all-purpose flour\"\n    },\n    {\n      \"name\": \"sugar\",\n      \"quantity\": \"150g plus 1¬Ω teaspoons\",\n      \"input\": \"150g plus 1¬Ω teaspoons sugar\"\n    }\n  ]\n}\n\n\nWhen I ran it while writing this vignette, it seemed to be working out the weight of the ingredients specified in volume, even though the prompt specifically asks it not to. This may suggest I need to broaden my examples."
  },
  {
    "objectID": "prompt-design.html#token-usage",
    "href": "prompt-design.html#token-usage",
    "title": "Prompt design",
    "section": "Token usage",
    "text": "Token usage\n\nfrom chatlas import token_usage\ntoken_usage()\n\n[{'name': 'Anthropic', 'input': 5663, 'output': 1093},\n {'name': 'OpenAI', 'input': 3017, 'output': 1153}]"
  },
  {
    "objectID": "get-started.html",
    "href": "get-started.html",
    "title": "chatlas",
    "section": "",
    "text": "chatlas makes it easy to access the wealth of large language models (LLMs) from Python. But what can you do with those models once you have access to them? This vignette will give you the basic vocabulary you need to use an LLM effectively and will show you some examples to ignite your creativity.\nIn this article we‚Äôll mostly ignore how LLMs work, using them as convenient black boxes. If you want to get a sense of how they actually work, we recommend watching Jeremy Howard‚Äôs posit::conf(2023) keynote: A hacker‚Äôs guide to open source LLMs."
  },
  {
    "objectID": "get-started.html#vocabulary",
    "href": "get-started.html#vocabulary",
    "title": "chatlas",
    "section": "Vocabulary",
    "text": "Vocabulary\nWe‚Äôll start by laying out the key vocab that you‚Äôll need to understand LLMs. Unfortunately the vocab is all a little entangled: to understand one term you‚Äôll often have to know a little about some of the others. So we‚Äôll start with some simple definitions of the most important terms then iteratively go a little deeper.\nIt all starts with a prompt, which is the text (typically a question or a request) that you send to the LLM. This starts a conversation, a sequence of turns that alternate between user prompts and model responses. Inside the model, both the prompt and response are represented by a sequence of tokens, which represent either individual words or subcomponents of a word. The tokens are used to compute the cost of using a model and to measure the size of the context, the combination of the current prompt and any previous prompts and responses used to generate the next response.\nIt‚Äôs useful to make the distinction between providers and models. A provider is a web API that gives access to one or more models. The distinction is a bit subtle because providers are often synonymous with a model, like OpenAI and GPT, Anthropic and Claude, and Google and Gemini. But other providers, like Ollama, can host many different models, typically open source models like LLaMa and Mistral. Still other providers support both open and closed models, typically by partnering with a company that provides a popular closed model. For example, Azure OpenAI offers both open source models and OpenAI‚Äôs GPT, while AWS Bedrock offers both open source models and Anthropic‚Äôs Claude.\n\nWhat is a token?\nAn LLM is a model, and like all models needs some way to represent its inputs numerically. For LLMs, that means we need some way to convert words to numbers. This is the goal of the tokenizer. For example, using the GPT 4o tokenizer, the string ‚ÄúWhen was R created?‚Äù is converted to 5 tokens: 5958 (‚ÄúWhen‚Äù), 673 (‚Äù was‚Äù), 460 (‚Äù R‚Äù), 5371 (‚Äù created‚Äù), 30 (‚Äú?‚Äù). As you can see, many simple strings can be represented by a single token. But more complex strings require multiple tokens. For example, the string ‚Äúcounterrevolutionary‚Äù requires 4 tokens: 32128 (‚Äúcounter‚Äù), 264 (‚Äúre‚Äù), 9477 (‚Äúvolution‚Äù), 815 (‚Äúary‚Äù). (You can see how various strings are tokenized at http://tiktokenizer.vercel.app/).\nIt‚Äôs important to have a rough sense of how text is converted to tokens because tokens are used to determine the cost of a model and how much context can be used to predict the next response. On average an English word needs ~1.5 tokens so a page might require 375-400 tokens and a complete book might require 75,000 to 150,000 tokens. Other languages will typically require more tokens, because (in brief) LLMs are trained on data from the internet, which is primarily in English.\nLLMs are priced per million tokens. State of the art models (like GPT-4o or Claude 3.5 sonnet) cost $2-3 per million input tokens, and $10-15 per million output tokens. Cheaper models can cost much less, e.g.¬†GPT-4o mini costs $0.15 per million input tokens and $0.60 per million output tokens. Even $10 of API credit will give you a lot of room for experimentation, particularly with cheaper models, and prices are likely to decline as model performance improves.\nTokens also used to measure the context window, which is how much text the LLM can use to generate the next response. As we‚Äôll discuss shortly, the context length includes the full state of your conversation so far (both your prompts and the model‚Äôs responses), which means that cost grow rapidly with the number of conversational turns.\n\n\nWhat is a conversation?\nA conversation with an LLM takes place through a series of HTTP requests and responses: you send your question to the LLM as an HTTP request, and it sends back its reply as an HTTP response. In other words, a conversation consists of a sequence of a paired turns: a sent prompt and a returned response.\nIt‚Äôs important to note that a request includes not only the current user prompt, but every previous user prompt and model response. This means that:\n\nThe cost of a conversation grows quadratically with the number of turns: if you want to save money, keep your conversations short.\nEach response is affected by all previous prompts and responses. This can make a converstion get stuck in a local optimum, so it‚Äôs generally better to iterate by starting a new conversation with a better prompt rather than having a long back-and-forth.\nchatlas has full control over the conversational history. Because it‚Äôs chatlas‚Äôs responsibility to send the previous turns of the conversation, it‚Äôs possible to start a conversation with one model and finish it with another.\n\n\n\nWhat is a prompt?\nThe user prompt is the question that you send to the model. There are two other important prompts that underlie the user prompt:\n\nThe core system prompt, which is unchangeable, set by the model provider, and affects every conversation. You can see what these look like from Anthropic, who publishes their core system prompts.\nThe system prompt, which is set when you create a new conversation, and affects every response. It‚Äôs used to provide additional instructions to the model, shaping its responses to your needs. For example, you might use the system prompt to ask the model to always respond in Spanish or to write dependency-free base R code. You can also use the system prompt to provide the model with information it wouldn‚Äôt otherwise know, like the details of your database schema, or your preferred plotly theme and color palette.\n\nWhen you use a chat app like ChatGPT or claude.ai you can only iterate on the user prompt. But when you‚Äôre programming with LLMs, you‚Äôll primarily iterate on the system prompt. For example, if you‚Äôre developing an app that helps a user write Python code, you‚Äôd work with the system prompt to ensure that user gets the style of code they want.\nWriting a good prompt, which is called prompt design, is key to effective use of LLMs. It is discussed in more detail in the prompt design article."
  },
  {
    "objectID": "get-started.html#example-uses",
    "href": "get-started.html#example-uses",
    "title": "chatlas",
    "section": "Example uses",
    "text": "Example uses\nNow that you‚Äôve got the basic vocab under your belt, I‚Äôm going to fire a bunch of interesting potential use cases at you. While there are special purpose tools that might solve these cases faster and/or cheaper, an LLM allows you to rapidly prototype a solution. This can be extremely valuable even if you end up using those more specialised tools in your final product.\nIn general, we recommend avoiding LLMs where accuracy is critical. That said, there are still many cases for their use. For example, even though they always require some manual fiddling, you might save a bunch of time even with an 80% correct solution. In fact, even a not-so-good solution can still be useful because it makes it easier to get started: it‚Äôs easier to react to something rather than to have to start from scratch with a blank page.\n\nChatbots\nA great place to start with chatlas and LLMs is to build a chatbot with a custom prompt. Chatbots are familiar interface and are easy to create via web application framework like Shiny or Streamlit. And there‚Äôs a surprising amount of value to creating a custom chatbot that has a prompt stuffed with useful knowledge. For example:\n\nHelp people use your new package. To do so, you need a custom prompt because LLMs were trained on data prior to your package‚Äôs existence. You can create a surprisingly useful tool just by preloading the prompt with your README and other documentation. This is how the chatlas assistant works.\nBuild language specific prompts for Python and/or R. Shiny assistant helps you build shiny apps (either in Python or R) by combining a prompt that gives general advice on building apps with a prompt for Python or R. The Python prompt is very detailed because there‚Äôs much less information about Shiny for Python in the existing LLM knowledgebases.\nHelp people find the answers to their questions. Even if you‚Äôve written a bunch of documentation for something, you might find that you still get questions because folks can‚Äôt easily find exactly what they‚Äôre looking for. You can reduce the need to answer these questions by creating a chatbot with a prompt that contains your documentation. For example, if you‚Äôre a teacher, you could create a chatbot that includes your syllabus in the prompt. This eliminates a common class of question where the data necessary to answer the question is available, but hard to find.\n\nAnother direction is to give the chatbot additional context about your current environment. For example, aidea allows the user to interactively explore a dataset with the help of the LLM. It adds summary statistics about the dataset to the prompt so that the LLM knows something about your data. Along these lines, imagine writing a chatbot to help with data import that has a prompt which include all the files in the current directory along with their first few lines.\n\n\nStructured data extraction\nLLMs are often very good at extracting structured data from unstructured text. This can give you traction to analyse data that was previously unaccessible. For example:\n\nCustomer tickets and GitHub issues: you can use LLMs for quick and dirty sentiment analysis by extracting any specifically mentioned products and summarising the discussion as a few bullet points.\nGeocoding: LLMs do a surprisingly good job at geocoding, especially extracting addresses or finding the latitute/longitude of cities. There are specialised tools that do this better, but using an LLM makes it easy to get started.\nRecipes: I‚Äôve extracted structured data from baking and cocktail recipes. Once you have the data in a structured form you can use your Python skills to better understand how recipes vary within a cookbook or to look for recipes that use the ingredients that you currently have in your kitchen. You could even use shiny assistant to help make those techniques available to anyone, not just Python users.\n\nStructured data extraction also work works well with images. It‚Äôs not the fastest or cheapest way to extract data but it makes it really easy to prototype ideas. For example, maybe you have a bunch of scanned documents that you want to index. You can convert PDFs to images (e.g.¬†using something like pdf2image) then use structured data extraction to pull out key details.\nLearn more in the article on structured data extraction.\n\n\nProgramming\nLLMs can also be useful to solve general programming problems. For example:\n\nYou can use LLMs to explain code, or even ask them to generate a diagram.\nYou can ask an LLM to analyse your code for potential code smells or security issues. You can do this a function at a time, or explore including the entire source code for your package or script in the prompt.\nYou could automatically look up the documentation for an Python class/function, and include it in the prompt to make it easier to figure out how to use that class/function.\nI find it useful to have an LLM document a function for me, even knowing that it‚Äôs likely to be mostly incorrect. Having something to react to make it much easier for me to get started.\nIf you‚Äôre working with code or data from another programming language, you ask an LLM to convert it to Python code for you. Even if it‚Äôs not perfect, it‚Äôs still typically much faster than doing everything yourself.\nYou could use GitHub‚Äôs REST API to find unlabelled issues, extract the text, and ask the LLM to figure out what labels might be most appropriate. Or maybe an LLM might be able to help people create better reprexes, or simplify reprexes that are too complicated?\nWrite a detailed prompt that teaches the LLM about something it wouldn‚Äôt otherwise know about. For example, you might write a guide to updating code to use a new version of a package. If you have a programmable IDE, you could imagine being able to select code, transform it, and then replace the existing text. A real example of this is the R package chores, which includes prompts for updating source code to use the latest conventions in R for documentation, testing, error handling, and more."
  },
  {
    "objectID": "get-started.html#miscellaneous",
    "href": "get-started.html#miscellaneous",
    "title": "chatlas",
    "section": "Miscellaneous",
    "text": "Miscellaneous\nTo finish up here are a few other ideas that seem cool but didn‚Äôt seem to fit the above categories:\n\nAutomatically generate alt text for plots, using content_image_plot().\nAnalyse the text of your statistical report to look for flaws in your statistical reasoning (e.g.¬†misinterpreting p-values or assuming causation where only correlation exists).\nUse your existing company style guide to generate a brand.yaml specification to automatically style your reports, apps, dashboards and plots to match your corporate style guide."
  },
  {
    "objectID": "tool-calling.html",
    "href": "tool-calling.html",
    "title": "Introduction",
    "section": "",
    "text": "One of the most interesting aspects of modern chat models is their ability to make use of external tools that are defined by the caller.\nWhen making a chat request to the chat model, the caller advertises one or more tools (defined by their function name, description, and a list of expected arguments), and the chat model can choose to respond with one or more ‚Äútool calls‚Äù. These tool calls are requests from the chat model to the caller to execute the function with the given arguments; the caller is expected to execute the functions and ‚Äúreturn‚Äù the results by submitting another chat request with the conversation so far, plus the results. The chat model can then use those results in formulating its response, or, it may decide to make additional tool calls.\nNote that the chat model does not directly execute any external tools! It only makes requests for the caller to execute them. It‚Äôs easy to think that tool calling might work like this:\n\n\n\nDiagram showing showing the wrong mental model of tool calls: a user initiates a request that flows to the assistant, which then runs the code, and returns the result back to the user.‚Äù\n\n\nBut in fact it works like this:\n\n\n\nDiagram showing the correct mental model for tool calls: a user sends a request that needs a tool call, the assistant request that the user‚Äôs runs that tool, returns the result to the assistant, which uses it to generate the final answer.\n\n\nThe value that the chat model brings is not in helping with execution, but with knowing when it makes sense to call a tool, what values to pass as arguments, and how to use the results in formulating its response.\n\nfrom chatlas import ChatOpenAI\n\n\nMotivating example\nLet‚Äôs take a look at an example where we really need an external tool. Chat models generally do not have access to ‚Äúreal-time‚Äù information, such as current events, weather, etc. Let‚Äôs see what happens when we ask the chat model about the weather in a specific location:\n\nchat = ChatOpenAI(model=\"gpt-4o-mini\")\n_ = chat.chat(\"What's the weather like today in Duluth, MN?\")\n\n\n\n\n\nI‚Äôm unable to provide real-time weather updates. For the most accurate and current weather information in Duluth, MN, I recommend checking a reliable weather website or app.\n\n\nFortunately, the model is smart enough to know that it doesn‚Äôt have access to real-time information, and it doesn‚Äôt try to make up an answer. However, we can help it out by providing a tool that can fetch the weather for a given location.\n\n\nDefining a tool function\nAt it turns out, LLMs are pretty good at figuring out ‚Äòstructure‚Äô like latitude and longitude from ‚Äòunstructured‚Äô things like a location name. So we can write a tool function that takes a latitude and longitude and returns the current temperature at that location. Here‚Äôs an example of how you might write such a function using the Open-Meteo API:\n\nimport requests\n\ndef get_current_temperature(latitude: float, longitude: float):\n    \"\"\"\n    Get the current weather given a latitude and longitude.\n\n    Parameters\n    ----------\n    latitude\n        The latitude of the location.\n    longitude\n        The longitude of the location.\n    \"\"\"\n    lat_lng = f\"latitude={latitude}&longitude={longitude}\"\n    url = f\"https://api.open-meteo.com/v1/forecast?{lat_lng}&current=temperature_2m,wind_speed_10m&hourly=temperature_2m,relative_humidity_2m,wind_speed_10m\"\n    response = requests.get(url)\n    json = response.json()\n    return json[\"current\"]\n\nNote that we‚Äôve gone through the trouble of adding the following to our function:\n\nType hints for function arguments\nA docstring that explains what the function does and what arguments it expects (as well as descriptions for the arguments themselves)\n\nProviding these hints and documentation is very important, as it helps the chat model understand how to use your tool correctly!\nLet‚Äôs test it:\n\nget_current_temperature(46.7867, -92.1005)\n\n{'time': '2025-05-29T21:45',\n 'interval': 900,\n 'temperature_2m': 26.1,\n 'wind_speed_10m': 11.6}\n\n\n\n\nUsing the tool\nIn order for the LLM to make use of our tool, we need to register it with the chat object. This is done by calling the register_tool method on the chat object.\n\nchat.register_tool(get_current_temperature)\n\nNow let‚Äôs retry our original question:\n\n_ = chat.chat(\"What's the weather like today in Duluth, MN?\")\n\n\n\n\n\n# üîß tool request (call_h0Ub9Bg3JT5bL9Mn8Yx0FmDs)\nget_current_temperature(latitude=46.7867, longitude=-92.1005)\n# ‚úÖ tool result (call_h0Ub9Bg3JT5bL9Mn8Yx0FmDs)\n{ 'time': '2025-05-29T21:45',\n  'interval': 900,\n  'temperature_2m': 26.1,\n  'wind_speed_10m': 11.6}\n\nThe current weather in Duluth, MN is 26.1¬∞C with a wind speed of 11.6 km/h.\n\n\nThat‚Äôs correct! Without any further guidance, the chat model decided to call our tool function and successfully used its result in formulating its response.\nThis tool example was extremely simple, but you can imagine doing much more interesting things from tool functions: calling APIs, reading from or writing to a database, kicking off a complex simulation, or even calling a complementary GenAI model (like an image generator). Or if you are using chatlas in a Shiny app, you could use tools to set reactive values, setting off a chain of reactive updates. This is precisely what the sidebot dashboard does to allow for an AI assisted ‚Äúdrill-down‚Äù into the data.\n\n\nTrouble-shooting\nWhen the execution of a tool function fails, chatlas sends the exception message back to the chat model. This can be useful for gracefully handling errors in the chat model. However, this can also lead to confusion as to why a response did not come back as expected. If you encounter such a situation, you can set echo=\"all\" in the chat.chat() method to see the full conversation, including tool calls and their results.\n\ndef get_current_temperature(latitude: float, longitude: float):\n    \"Get the current weather given a latitude and longitude.\"\n    raise ValueError(\"Failed to get current temperature\")\n\nchat.register_tool(get_current_temperature)\n\n_ = chat.chat(\"What's the weather like today in Duluth, MN?\")\n\n\n\n\n\n# üîß tool request (call_emhS8SruPNKxSblve0tZ6DLy)\nget_current_temperature(latitude=46.7867, longitude=-92.1005)\n# ‚ùå tool error (call_emhS8SruPNKxSblve0tZ6DLy)\nTool call failed with error: 'Failed to get current temperature'\n\nI encountered an issue retrieving the current weather information for Duluth, MN. However, you can check a reliable weather website or app for up-to-date information. Would you like me to help you with something else?\n\n\n/home/runner/work/chatlas/chatlas/chatlas/_chat.py:1265: ToolFailureWarning: Calling tool 'get_current_temperature' led to an error.\n  res = self._invoke_tool(x)\nNoneType: None\n\n\n\n\nTool limitations\nRemember that tool arguments come from the chat model, and tool results are returned to the chat model. That means that only simple, JSON-compatible data types can be used as inputs and outputs. It‚Äôs highly recommended that you stick to basic types for each function parameter (e.g.¬†str, float/int, bool, None, list, tuple, dict). And you can forget about using functions, classes, external pointers, and other complex (i.e., non-serializable) Python objects as arguments or return values. Returning data frames seems to work OK (as long as you return the JSON representation ‚Äì .to_json()), although be careful not to return too much data, as it all counts as tokens (i.e., they count against your context window limit and also cost you money)."
  }
]